<html>
    <head>
        <title id="titell">something has gone very wrong</title>
        <style>
            html {
                background: #222;
                color: white;
            }
            canvas {
                background: #888;
            }
        </style>
        <script>
            let VERSION = "v0.0.4.1"; // It's gonna be awhile before this is relevant
            document.getElementById("titell").textContent = "wetlands " + VERSION;
            let ctx, elapsedTime = 0;
            let mousey = 0, mousex = 0;
            
            let pressedKeys = {};
            window.onkeyup = function(e) { pressedKeys[e.keyCode] = false; }
            window.onkeydown = function(e) { pressedKeys[e.keyCode] = true; newKeys.push(e.keyCode); }
            
            // found on stackoverflow
            function rotate(centerx, centery, x, y, degrees) {
                let newx = (x - centerx) * Math.cos(degrees * Math.PI / 180) - (y - centery) * Math.sin(degrees * Math.PI / 180) + centerx;
                let newy = (x - centerx) * Math.sin(degrees * Math.PI / 180) + (y - centery) * Math.cos(degrees * Math.PI / 180) + centery;
                return [newx, newy];
            }
            
            function drawBody(t, l, r, c = "white") {
                ctx.lineWidth = r;
                ctx.lineCap = "round";
                for(let i=0; i<l.length; i++) {
                    line(t.bodyCoords(l[i]), t.bodyCoords(i + 1 == l.length ? l[0] : l[i + 1]), c);
                }
                ctx.beginPath();
                ctx.fillStyle = c;
                for(let i of l) {
                    ctx.lineTo(...t.bodyCoords(i));
                }
                ctx.fill();
            }
            function circle(p, r, c = "black", f = true) {
                if(f) {ctx.fillStyle = c;} else {ctx.strokeStyle = c;}
                ctx.beginPath();
                ctx.arc(...p, r, 0, 2 * Math.PI);
                if(f) {ctx.fill();} else {ctx.stroke();}
            }
            function line(p, q, c = "white") {
                ctx.strokeStyle = c;
                ctx.beginPath();
                ctx.moveTo(p[0], p[1]);
                ctx.lineTo(q[0], q[1]);
                ctx.stroke();
            }
            
            class Pole {
                // You know those climbable poles? This is them
                constructor(start, end, other, dir) {
                    this.start = start;
                    this.end = end;
                    this.other = other;
                    this.dir = dir;
                }
                render() {
                    ctx.lineWidth = 8;
                    if(this.dir == "v") {
                        line([this.other, this.start], [this.other, this.end], "black");
                    } else {
                        line([this.start, this.other], [this.end, this.other], "black");
                    }
                }
            }
            
            class Rectangle {
                constructor(x, y, w, h, c = "white", f = true) {
                    this.xpos = x;
                    this.ypos = y;
                    this.width = w;
                    this.height = h;
                    this.color = c;
                    this.fill = f;
                }
                render() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    if(this.fill) {ctx.fillRect(this.xpos, this.ypos, this.width, this.height);}
                    else {ctx.strokeRect(this.xpos, this.ypos, this.width, this.height);}
                }
                touches(other) {
                    if(other instanceof Rectangle) {
                        if(this.xpos + this.width > other.xpos && this.xpos < other.xpos + other.width &&
                           this.ypos + this.height > other.ypos && this.ypos < other.ypos + other.height) {
                            return true;
                        }
                    } else if(other instanceof Polygon || other instanceof Hitbox) {
                        // implemented in the other class
                        return other.touches(this);
                    }
                    return false;
                }
            }
            
            class Polygon {
                constructor(p, c = "white", f = true) {
                    this.points = p;
                    this.lines = p.map(function(x, i) {
                        let n = (i + 1 == p.length ? p[0] : p[i + 1]);
                        let d = {p1: x, p2: n, x1: x[0], y1: x[1], x2: n[0], y2: n[1]};
                        // 8th grade math is paying off!
                        d.length = Math.sqrt((d.y2 - d.y1) * (d.y2 - d.y1) + (d.x2 - d.x1) * (d.x2 - d.x1));
                        d.slope = (d.y2 - d.y1) / (d.x2 - d.x1);
                        d.yIntercept = d.y1 - d.x1 * d.slope;
                        return d;
                    });
                    this.color = c;
                    this.fill = f;
                }
                render() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(...this.points[0]);
                    for(let i of this.points.slice(1)) {
                        ctx.lineTo(...i);
                    }
                    if(this.fill) {ctx.fill();} else {ctx.closePath(); ctx.stroke();}
                }
                touches(other) {
                    if(other instanceof Rectangle) {
                        // Turn the rectangle into a polygon
                        let x2 = other.width + other.xpos;
                        let y2 = other.height + other.ypos;
                        return this.touches(new Polygon([
                            [other.xpos, other.ypos],
                            [other.xpos, y2],
                            [x2, y2],
                            [x2, other.ypos]
                        ]));
                    } else if(other instanceof Polygon) {
                        for(let i of this.lines) {
                            for(let j of other.lines) {
                                // grabbed this off stack overflow
                                let det, gamma, lambda;
                                let a = i.x1, b = i.y1, c = i.x2, d = i.y2;
                                let p = j.x1, q = j.y1, r = j.x2, s = j.y2;
                                det = (c - a) * (s - q) - (r - p) * (d - b);
                                if(det) {
                                    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
                                    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
                                    if((0 < lambda && lambda < 1) && (0 < gamma && gamma < 1)) return true;
                                }
                            }
                        }
                    } else if(other instanceof Hitbox) {
                        // implemented in the other class
                        return other.touches(this);
                    }
                    return false;
                }
                dims() {
                    let ys = this.points.map(x => x[1]).sort();
                    let xs = this.points.map(x => x[0]).sort();
                    return {top: ys[0], left: xs[0], right: xs[xs.length - 1], bottom: ys[ys.length - 1]};
                }
            }
            
            class Hitbox {
                // A group of shapes, handy for making hitboxes
                constructor(s, uo = [], r = 0) {
                    let shapes = (s[0] ? s : [s]);
                    this.shapes = shapes;
                    this.ignoreUUIDs = uo;
                    this.room = r; // for contact()
                }
                touches(other) {
                    for(let i of this.shapes) {
                        if(i.touches(other)) return i;
                    }
                    return false;
                }
                contact(doEnts = true, wEnts = "") {
                    // Basically the same as AbstractEntity's contact() method
                    let r = (this.room ? this.room : SC.room); // use SC's room if none specified
                    let ents = r.entities.filter(x=>!this.ignoreUUIDs.includes(x.uuid)).map(x=>x.getHitbox(wEnts)).map(y => y instanceof Hitbox ? y.shapes : [y]);
                    //alert(JSON.stringify(ents.flat(1).map(x=>x.points||x.width)));
                    //return (w ? this.getHitbox(w) : this.getHitbox()).touches(new Hitbox(ents.flat(1)));
                    return this.touches(doEnts ? new Hitbox([...ents.flat(1), ...r.hitbox.shapes]) : r.hitbox);
                }
            }
            
            class Room {
                constructor(fg, mg, bg, p) {
                    // These are lists of polygons that get called to draw the room.
                    this.foreground = fg;
                    this.midground = mg;
                    this.background = bg;
                    this.poles = p;
                    this.hitbox = new Hitbox(mg);
                    this.entities = []; // The entities in the room
                    this.width = 1350; // Will be configurable later
                    this.height = 630; // Will be configurable later
                    this.grids = {};
                }
                render() {
                    for(let i of this.background) {i.render();}
                    for(let j of this.entities) {j.render();}
                    for(let p of this.poles) {p.render();}
                    // For the SC specifically, render the hands on top
                    if(SC.room == this) SC.doHands();
                    for(let l of this.midground) {l.render();}
                    for(let k of this.foreground) {k.render();}
                }
                grid(by, big = 10, strict = 0, liz = false) {
                    if(this.grids[strict+"»"+big+"»"+by]) return this.grids[strict+"»"+big+"»"+by];
                    let grid = [];
                    for(let i=0; i<=this.height/big; i++) {
                        grid.push([]);
                        for(let j=0; j<=this.width/big; j++) {
                            let h = new Hitbox(new Rectangle(big * j - strict, big * i - strict, big + strict * 2, big + strict * 2), [by], this);
                            let c = h.contact();
                            if(liz) {
                                let s2 = strict + 50;
                                // DON'T stop hitbox check from checking the lizard itself, otherwise it will start in midair
                                let h2 = new Hitbox(new Rectangle(big * j - s2, big * i - s2, big + s2 * 2, big + s2 * 2), [], this);
                                let c2 = h2.contact();
                                grid[i].push((c || !c2) ? true : false);
                            } else {
                                grid[i].push(c ? true : false);
                            }
                        }
                    }
                    this.grids[strict+"»"+big+"»"+by] = grid;
                    return grid;
                }
            }
            
            class Position {
                // A really simple class
                constructor(x, y, a=0, cx=0, cy=0, a2=0, cx2=0, cy2=0) {
                    this.REAL_xpos = x;
                    this.REAL_ypos = y;
                    this.cx = cx;
                    this.cy = cy;
                    this.angle = a;
                    this.secondCx = cx2;
                    this.secondCy = cy2;
                    this.secondAngle = a2;
                    this.owner = null;
                }
                
                get xpos() {
                    return rotate(this.secondCx, this.secondCy, ...rotate(this.cx, this.cy, this.REAL_xpos, this.REAL_ypos, this.angle), this.secondAngle)[0];
                }
                set xpos(v) {this.REAL_xpos = v;}
                
                get ypos() {
                    return rotate(this.secondCx, this.secondCy, ...rotate(this.cx, this.cy, this.REAL_xpos, this.REAL_ypos, this.angle), this.secondAngle)[1];
                }
                set ypos(v) {this.REAL_ypos = v;}
            }
            
            class PathfinderPoint {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.f = 0; // I have no //
                    this.g = 0; // idea what //
                    this.h = 0; // these are //
                    this.neighbors = [];
                    this.parent = undefined;
                }
                neighbify(g) {
                    let n = [];
                    if(this.y) n.push(g[this.y - 1][this.x]);
                    if(this.y + 1 < g.length) n.push(g[this.y + 1][this.x]);
                    if(this.x) n.push(g[this.y][this.x - 1]);
                    if(this.x + 1 < g[0].length) n.push(g[this.y][this.x + 1]);
                    return n;
                }
            }
            
            class AbstractEntity {
                constructor(n, r, x, y, s, b, g, re, t) {
                    this.id = n;
                    this.uuid = Math.random();
                    this.room = r;
                    r.entities.push(this);
                    this.xpos = x;
                    this.ypos = y;
                    this.xvel = 0;
                    this.yvel = 0;
                    this.state = s;
                    this.body = b;
                    for(let i of Object.values(this.body)) {
                        i.owner = this;
                    }
                    this.dead = false;
                    this.completePath = false;
                    this.getHitbox = g;
                    this.render = re;
                    this.tick = t;
                }
                bodyCoords(b, xtrax = 0, xtray = 0) {
                    return [this.body[b].xpos + this.xpos + xtrax, this.body[b].ypos + this.ypos + xtray];
                }
                contact(doEnts = true, w = "", w2 = "") {
                    let ents = this.room.entities.filter(z=>z.uuid!=this.uuid).map(x=>x.getHitbox(w2)).map(y => y instanceof Hitbox ? y.shapes : [y]);
                    //alert(JSON.stringify(ents.flat(1).map(x=>x.points||x.width)));
                    //return (w ? this.getHitbox(w) : this.getHitbox()).touches(new Hitbox(ents.flat(1)));
                    return (w ? this.getHitbox(w) : this.getHitbox()).touches(doEnts ? new Hitbox([...ents.flat(1), ...this.room.hitbox.shapes]) : this.room.hitbox);
                }
                in(state) {
                    return this.state.includes(state + ".");
                }
                onPole(p, w = "") {
                    // Check if the entity is colliding with a pole
                    return this.getHitbox(w).touches(new Rectangle(...(
                        p.dir == "h" ? [p.start, p.other - 1, p.end - p.start, 2] : [p.other - 1, p.start, 2, p.end - p.start]
                    )));
                }
                canSee(other) {
                    // Get the line of sight from this to other, and see if it's obstructed.
                    // LATER! Maybe try to check all the body chunks? I'll just do the real position for now
                    let line = new Polygon([this.centerPos, other.centerPos]);
                    return !(new Hitbox(line, [this.uuid, other.uuid]).contact()); // LATER! maybe try to allow partial vision through entities
                }
                pathfind(goalPoint, bigness = 10, strictness = 0, maxMs = 50, liz = false) {
                    let t1 = Date.now();
                    // Set up points
                    // Hmm............................ does this part need to be (x, y)?
                    let grid = this.room.grid(this.uuid, bigness, strictness, liz).map((x,a)=>x.map((y,b)=>new PathfinderPoint(b, a)));
                    // Might want to try diagonals?
                    let heuristic = (p0, p1) => Math.abs(p1.x - p0.x) + Math.abs(p1.y - p0.y);
                    // end = pos of goal point
                    // start = where u are now
                    // openSet = start
                    // closedSet = untraversable points / already traversed points
                    // grid = 2D array, of columns then rows
                    
                    // Search code, found on [dev.to/codesphere/pathfinding-with-javascript-the-a-algorithm-3jlb]
                    let x = Math.min(this.room.width, Math.max(0, this.xpos));
                    let y = Math.min(this.room.height, Math.max(0, this.ypos));
                    let gx = Math.min(this.room.width, Math.max(0, goalPoint[0]));
                    let gy = Math.min(this.room.height, Math.max(0, goalPoint[1] + (liz ? 50 : 0)));
                    let end = grid[Math.floor(gy / bigness)][Math.floor(gx / bigness)];
                    let start = grid[Math.floor(y / bigness)][Math.floor(x / bigness)], path = [], openSet = [start], closedSet = [];
                    for(let i=0; i<grid.length; i++) {
                        for(let j=0; j<grid[0].length; j++) {
                            grid[i][j].neighbify(grid);
                        }
                    }
                    
                    let current;
                    while(openSet.length > 0) {
                        let li = 0;
                        for(let i = 0; i < openSet.length; i++) {
                            if(openSet[i].f < openSet[li].f) li = i;
                        }
                        current = openSet[li];
                        if(current == end || (liz && heuristic(current, end) < 5)) {
                            let temp = current;
                            path.push(temp);
                            while(temp.parent) {path.push(temp.parent); temp = temp.parent;}
                            this.completePath = true;
                            return path.reverse();
                        }
                        openSet.splice(li, 1);
                        closedSet.push(current);
                        let neighbors = current.neighbify(grid);
                        for(let i = 0; i < neighbors.length; i++) {
                            let n = neighbors[i];
                            if(!closedSet.includes(n) && (!this.room.grid(this.uuid, bigness, strictness, liz)[n.y][n.x] || n == end)) {
                                let possibleG = current.g + 1;
                                if(!openSet.includes(n)) openSet.push(n);
                                else if(possibleG >= n.g) continue;
                                n.g = possibleG;
                                n.h = heuristic(n, end);
                                n.f = n.g + n.h;
                                n.parent = current;
                            }
                        }
                        // If it takes too long, give up to avoid lagging the rest of the program
                        if(maxMs && (Date.now() - t1) >= maxMs) {
                            //alert("FAILED TO FINISH IN " + maxMs + "MS - RETURNING CURRENT PATH");
                            let temp = current;
                            path.push(temp);
                            while(temp.parent) {path.push(temp.parent); temp = temp.parent;}
                            this.completePath = false;
                            return path.reverse();
                        }
                    }
                    // Can't quite make it. Get as far as you can?
                    let temp = current;
                    path.push(temp);
                    while(temp.parent) {path.push(temp.parent); temp = temp.parent;}
                    this.completePath = false;
                    return path.reverse();
                }
            }
            
            class Lizard extends AbstractEntity {
                constructor(name, col, col2, room, xpoz, ypoz) {
                    super(
                        name, room, xpoz, ypoz, "stand.idle", {
                            // um um uh what goes here
                            headTU: new Position(5, 0),
                            headBU: new Position(0, 20),
                            headTL: new Position(0, 80),
                            headBL: new Position(0, 85),
                            headTB: new Position(80, 30),
                            headBB: new Position(80, 70),
                            headI: new Position(70, 50),
                            eye: new Position(7, 7),
                            mid1T: new Position(130, 30),
                            mid1B: new Position(130, 70),
                            mid2T: new Position(200, 30),
                            mid2B: new Position(200, 70),
                            backT: new Position(300, 30),
                            backB: new Position(300, 70),
                            legFLS: new Position(140, 70),
                            legFLE: new Position(140, 100),
                            legBLS: new Position(240, 70),
                            legBLE: new Position(240, 100),
                            legFRS: new Position(180, 70),
                            legFRE: new Position(180, 100),
                            legBRS: new Position(280, 70),
                            legBRE: new Position(280, 100)
                        }, function(w = "default") {
                            // get hitbox ugh
                            return new Polygon([
                                // I could have added all the legs in the hitbox but didn't feel like it
                                this.bodyCoords("headTU"),
                                this.bodyCoords("headBU"),
                                this.bodyCoords("headI"),
                                this.bodyCoords("headTL"),
                                this.bodyCoords("headBL"),
                                this.bodyCoords("headBB"),
                                this.bodyCoords("legFLS"),
                                this.bodyCoords("legFLE"),
                                this.bodyCoords("legBRE"),
                                this.bodyCoords("legBRS"),
                                this.bodyCoords("backB"),
                                this.bodyCoords("backT"),
                                this.bodyCoords("headTB")
                            ]);
                        }, function() {
                            // Legs
                            ctx.lineWidth = 10;
                            line(this.bodyCoords("legFLS"), this.bodyCoords("legFLE"), this.primary);
                            line(this.bodyCoords("legBLS"), this.bodyCoords("legBLE"), this.primary);
                            line(this.bodyCoords("legFRS"), this.bodyCoords("legFRE"), this.secondary);
                            line(this.bodyCoords("legBRS"), this.bodyCoords("legBRE"), this.secondary);
                            // Body
                            drawBody(this, ["headBB", "headTB", "mid1T", "mid2T", "backT", "backB", "mid2B", "mid1B"], 7, "black");
                            // Head
                            drawBody(this, ["headTU", "headBU", "headI", "headTL", "headBL", "headBB", "headTB"], 7, this.primary);
                            circle(this.bodyCoords("eye"), 5);
                            // LATER! Teeth & other features
                        }, function() {
                            // LARGE! Tick function
                            
                            // ---- Step 1: Find Goal
                            // Sort visible creatures by distance and edibility/danger
                            let visibles = this.room.entities.filter(x=>x.uuid!=this.uuid/*&&this.canSee(x)*/);
                            for(let i of visibles) {
                                this.memories[i.uuid] = {uuid: i.uuid, obj: i, pos: i.centerPos, time: elapsedTime};
                            }
                            
                            if(Object.values(this.memories).length && !visibles.length) {
                                //alert(`${this.id}${this.uuid.toString().slice(2, 7)} says: I am tracking you`);
                            }
                            
                            // Draw lines (PURELY GRAPHICAL, CAN BE REMOVED LATER)
                            let shouldDraw = true;
                            if(shouldDraw) {
                                ctx.lineWidth = 3;
                                for(let j of Object.values(this.memories)) {
                                    let oldness = 1 - 0.0001 * (elapsedTime - j.time);
                                    line(this.centerPos, j.pos, "rgba(255, 255, 0, " + oldness + ")");
                                }
                                for(let i of this.room.entities.filter(x=>x.uuid!=this.uuid)) {
                                    let cs = this.canSee(i);
                                    line(this.centerPos, i.centerPos, (cs ? "lime" : "red"));
                                }
                            }
                            
                            // Get best (closest & most edible/dangerous) creature (memories weighted based on oldness)
                            let cp = this.centerPos, rel = this.relations;
                            let best;
                            if(visibles.length) {
                                best = visibles.map(function(a) {
                                    let distA = new Polygon([cp, a.centerPos]).lines[0].length;
                                    let valA = (rel[a.id] || 0) / distA;
                                    return {obj: a, uuid: a.uuid, v: valA, pos: a.centerPos, mem: false};
                                }).sort((x, y) => (x.v > y.v ? 1 : y.v > x.v ? -1 : 0))[0];
                            }
                            let found = (best ? true : false);
                            // Best will be in the format [uuid, value]
                            // Now see if any memories are better than the best visible one
                            for(let i of Object.values(this.memories)) {
                                let distI = new Polygon([cp, i.pos]).lines[0].length;
                                let valI = (rel[i.obj.id] || 0) / distI;
                                valI *= Math.max(0, 1 - 0.0001 * (elapsedTime - i.time));
                                if(!best || valI > best.v) best = {obj: i.obj, uuid: i.uuid, v: valI, pos: i.pos, mem: true};
                            }
                            
                            // If no visible edible/dangerous creatures, just get a better vantage point?
                            // LATER! this ^^
                            // ---- Step 2: Pathing
                            let path;
                            let HOWBIG = 20; // Raise this to speed up pathfinding
                            let MAXTIME = 10; // Lizors can pathfind for this # of ms MAX, then they give up, might lower this later
                            if(best && (!best.obj || rel[best.obj.id] > 0)) {
                                let t1 = Date.now();
                                path = this.pathfind(best.pos, HOWBIG, 10, MAXTIME, true);
                                ctx.strokeStyle = (this.completePath ? "violet" : "pink");
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(...this.centerPos);
                                for(let i of path) {
                                    ctx.lineTo(i.x * HOWBIG, i.y * HOWBIG);
                                }
                                ctx.stroke();
                            }
                            // ---- Step 3: Movement
                            if(path) {
                                // Determine which direction to go, based on the 1st point whose X differs
                                let dir = 0, tries = 0;
                                while(tries < 20) {
                                    if(!path[tries]) break;
                                    dir = path[tries].x - path[0].x;
                                    if(dir) break; else tries++;
                                }
                                if(this.in("stand")) {
                                    if(dir > 0 && this.facing == 1) {
                                        this.xvel += (this.completePath ? 0.15 : 0.03);
                                        this.state = "stand.walk";
                                    } else if(dir > 0 && this.facing == -1) {
                                        // Turn.
                                    } else if(dir < 0 && this.facing == -1) {
                                        this.xvel -= (this.completePath ? 0.15 : 0.03);
                                        this.state = "stand.walk";
                                    } else if(dir < 0 && this.facing == 1) {
                                        // Turn.
                                    } else {
                                        this.state = "stand.idle";
                                        this.lgp = [140, 180, 240, 280];
                                    }
                                }
                            }
                            
                            // Mouth open-ness
                            let speed = 1;
                            let oa = this.mouthOpen;
                            let finished = this.mouthOpen == this.mouthGoal;
                            let was = this.contact();
                            if(this.mouthOpen < this.mouthGoal) {
                                this.mouthOpen = Math.min(this.mouthGoal, this.mouthOpen + speed);
                            } else {
                                this.mouthOpen = Math.max(this.mouthGoal, this.mouthOpen - speed);
                            }
                            for(let i of ["headBU", "headTU", "headBL", "headTL", "eye"]) {
                                this.body[i].angle = this.mouthOpen * (i.includes("L") ? -0.5 : 0.5);
                                this.body[i].cx = this.body.headI.xpos;
                                this.body[i].cy = this.body.headI.ypos;
                            }
                            
                            // Angle change -> contact
                            if(this.contact() && !finished) {
                                this.mouthOpen = oa;
                                //this.xvel = this.facing * -4;
                                //this.xpos += this.xvel;
                            }
                            
                            // Animation
                            if(this.state == "stand.walk") {
                                for(let i=0; i<=3; i++) this.lgp[i] -= this.xvel;
                                if(this.facing == 1) {
                                    if(this.lgp[0] <= 100) this.lgp[0] = 160;
                                    if(this.lgp[2] <= 200) this.lgp[2] = 260;
                                    if(this.lgp[1] <= 160) this.lgp[1] = 220;
                                    if(this.lgp[3] <= 260) this.lgp[3] = 320;
                                } else {
                                    if(this.lgp[0] >= 160) this.lgp[0] = 100;
                                    if(this.lgp[2] >= 260) this.lgp[2] = 200;
                                    if(this.lgp[1] >= 220) this.lgp[1] = 160;
                                    if(this.lgp[3] >= 320) this.lgp[3] = 260;
                                }
                            }
                            if(!this.contact()) {
                                this.body.legFLE.xpos += 0.1 * (this.lgp[0] - this.body.legFLE.xpos);
                                if(this.contact()) this.body.legFLE.xpos -= 0.1 * (this.lgp[0] - this.body.legFLE.xpos);
                            }
                            if(!this.contact()) {
                                this.body.legFRE.xpos += 0.1 * (this.lgp[1] - this.body.legFRE.xpos);
                                if(this.contact()) this.body.legFRE.xpos -= 0.1 * (this.lgp[1] - this.body.legFRE.xpos);
                            }
                            if(!this.contact()) {
                                this.body.legBLE.xpos += 0.1 * (this.lgp[2] - this.body.legBLE.xpos);
                                if(this.contact()) this.body.legBLE.xpos -= 0.1 * (this.lgp[2] - this.body.legBLE.xpos);
                            }
                            if(!this.contact()) {
                                this.body.legBRE.xpos += 0.1 * (this.lgp[3] - this.body.legBRE.xpos);
                                if(this.contact()) this.body.legBRE.xpos -= 0.1 * (this.lgp[3] - this.body.legBRE.xpos);
                            }
                            // just do some basic stuff for now.
                            this.xpos += this.xvel;
                            let xContact = false;
                            if(this.contact()) {
                                let checks = 0;
                                let xc = -0.1, yc = -0.4;
                                while(checks < 10 && this.contact() && !this.in("fall")) { // No, you can't WALK up while FALLING
                                    this.xpos += xc * this.xvel;
                                    this.ypos += yc * Math.abs(this.xvel);
                                    checks++;
                                }
                                if(checks == 10 || this.in("fall")) {
                                    this.xpos -= this.xvel;
                                    this.ypos -= yc * checks * Math.abs(this.xvel);
                                    this.xpos -= xc * checks * this.xvel;
                                    this.lgp = [140, 180, 240, 280];
                                    this.xvel *= 0.8;
                                    xContact = true;
                                }
                            }
                            // Horizontal friction
                            if(this.in("fall")) this.xvel *= 0.98;
                            else this.xvel *= 0.95;
                            
                            this.ypos += this.yvel + 3;
                            // Vertical stuff
                            let yContact = 0;
                            if(this.contact() && this.in("fall")) {
                                yContact = this.yvel;
                                this.ypos -= this.yvel * 2;
                                // This might not be needed
                                let c1 = this.contact();
                                this.xvel += this.facing * 3;
                                let c = this.contact();
                                this.xvel -= this.facing * 3;
                                if(!c1 && !c) {
                                    this.state = "stand.idle";
                                }
                                let fix = 0;
                                while(this.contact() && fix < 20) {
                                    // Um, what?
                                    fix++;
                                    this.ypos -= 10;
                                }
                                if(this.contact()) {
                                    // WHAT?!?!
                                    alert("This isn't good...");
                                }
                                this.yvel = 0;
                            } else if(this.in("fall")) {
                                this.yvel += 0.2; // Gravity
                            }
                            this.ypos += 3;
                            if(!this.contact() && !this.in("fall") && this.state != "crouch.climb") {
                                this.state = "fall.idle";
                                //alert("bonk!");
                            }
                            this.ypos -= 6;
                        }
                    );
                    this.primary = col; this.secondary = col2; // Coloring
                    this.facing = -1;
                    this.memories = {}; // Where this lizor saw something and might wanna investigate
                    this.relations = {"sc": 100}; // Positive = wants to follow, negative = wants to avoid
                    this.lgp = [140, 180, 240, 280];
                    this.mouthOpen = 0; // How open this lizor's mouth is
                    this.mouthGoal = 120; // How open it wants to be
                }
                get centerPos() {
                    return this.bodyCoords("eye");
                }
            }
            
            class PinkLizard extends Lizard {
                constructor(room, xpoz, ypoz) {
                    super("pinkliz", "#f6b", "#c26", room, xpoz, ypoz);
                    // After super call, change stuff as needed
                }
            }
            
            class Player extends AbstractEntity {
                constructor(room, xpoz, ypoz) {
                    super(
                        // State determines key handling, hitboxes?, and rendering
                        // Second part of state is more precise
                        "sc", room, xpoz, ypoz, "fall.idle",
                        // These are the OFFSETS not the ABSOLUTE positions
                        {
                            bodyTL: new Position(5, 0), bodyTR: new Position(35, 0),
                            bodyML: new Position(5, 35), bodyMR: new Position(35, 35),
                            legLS: new Position(5, 70), legLE: new Position(5, 90),
                            legRS: new Position(35, 70), legRE: new Position(35, 90),
                            armLS: new Position(10, 30), armLE: new Position(10, 30),
                            armRS: new Position(30, 30), armRE: new Position(30, 30),
                            eyeL: new Position(9, 11), eyeR: new Position(31, 11),
                            earLS: new Position(5, 0), earLE: new Position(5, -5),
                            earRS: new Position(35, 0), earRE: new Position(35, -5),
                            nouth: new Position(20, 20), // Not a typo, the N is intentional!
                        },
                        function(w = "full") {
                            // This should do for now
                            if(w == "top") { return new Polygon([
                                this.bodyCoords("bodyTL"),
                                this.bodyCoords("bodyML"),
                                this.bodyCoords("legLS"),
                                this.bodyCoords("legRS"),
                                this.bodyCoords("bodyMR"),
                                this.bodyCoords("bodyTR")
                            ]); } else { return new Polygon([
                                this.bodyCoords("bodyTL"),
                                this.bodyCoords("bodyML"),
                                this.bodyCoords("legLS"),
                                this.bodyCoords("legLE"),
                                this.bodyCoords("legRE"),
                                this.bodyCoords("legRS"),
                                this.bodyCoords("bodyMR"),
                                this.bodyCoords("bodyTR")
                            ]); }
                        },
                        function() {
                            let showTail = true, showFace = true, showLegs = !this.backflipping, showArms = (this.in("climb") || this.in("balance") || this.in("crouch"));
                            
                            // middle part
                            drawBody(this, ["bodyTL", "bodyTR", "bodyMR", "legRS", "legLS", "bodyML"], 10);
                            
                            if(showLegs) {
                                let lle = this.bodyCoords("legLE"), lre = this.bodyCoords("legRE");
                                if(this.in("roll")) {
                                    lle[0] = this.bodyCoords("legLS")[0];
                                    lle[1] = this.bodyCoords("legLS")[1];
                                    lre[0] = this.bodyCoords("legRS")[0];
                                    lre[1] = this.bodyCoords("legRS")[1];
                                }    
                                line(this.bodyCoords("legLS"), lle);
                                line(this.bodyCoords("legRS"), lre);
                            }
                            line(this.bodyCoords("earLS"), this.bodyCoords("earLE"));
                            line(this.bodyCoords("earRS"), this.bodyCoords("earRE"));
                            
                            if(showTail) {
                                let offx = 0.25 * this.angle, offy = 0.17 * Math.abs(this.angle), sizeMult = 1;
                                if(this.in("crouch")) offx += this.facing * 7;
                                if(this.backflipping) {
                                    // Backflips are a "little" bit strange
                                    offx = -50 * Math.sin(this.angle * Math.PI / 180);
                                    offy = -30 + 40 * Math.cos(this.angle * Math.PI / 180);
                                    this.DEBUGGO = [offx.toFixed(3), offy.toFixed(3)];
                                }
                                if(this.noFall) {
                                    // Use *pi/180 to convert deg to rad for use in trig func
                                    offy = -30 + 50 * Math.cos(this.angle * Math.PI / 180);
                                    offx = 40 * Math.cos((90 + this.angle) * Math.PI / 180);
                                }
                                for(let i of this.tail) {
                                    circle([i[0] + this.xpos + offx, i[1] + this.ypos + offy], sizeMult * (20 - 1 * this.tail.indexOf(i)), "white");
                                }
                            }
                            if(showArms) {
                                ctx.lineWidth = 10;
                                line(this.bodyCoords("armLS"), this.bodyCoords("armLE"));
                                line(this.bodyCoords("armRS"), this.bodyCoords("armRE"));
                            } else if(!this.angle) {
                                // Try to hide the arms a little... but don't try too hard
                                ctx.lineWidth = 10;
                                line([this.xpos + 20, this.ypos + 30], this.bodyCoords("armLE"));
                                line([this.xpos + 20, this.ypos + 30], this.bodyCoords("armRE"));
                            }
                            if(showFace) {
                                if(this.dead) {
                                    // LATER! x_x
                                } else if(this.stunTime) {
                                    ctx.lineWidth = 3;
                                    // LATER! >_<
                                    line(this.bodyCoords("eyeL", 0.5 * this.xvel + 2, 3), this.bodyCoords("eyeL", 0.5 * this.xvel), "black");
                                    line(this.bodyCoords("eyeL", 0.5 * this.xvel - 2, 3), this.bodyCoords("eyeL", 0.5 * this.xvel), "black");
                                    line(this.bodyCoords("eyeR", 0.5 * this.xvel + 2, 3), this.bodyCoords("eyeR", 0.5 * this.xvel), "black");
                                    line(this.bodyCoords("eyeR", 0.5 * this.xvel - 2, 3), this.bodyCoords("eyeR", 0.5 * this.xvel), "black");
                                } else {
                                    // °.°
                                    ctx.lineWidth = 10;
                                    circle(this.bodyCoords("eyeL", 0.5 * this.xvel), 5);
                                    circle(this.bodyCoords("eyeR", 0.5 * this.xvel), 5);
                                }
                                circle(this.bodyCoords("nouth", 0.5 * this.xvel), 3);
                            }
                        },
                        function() {
                            // Controls
                            let turnaround = 0.3;
                            if(this.in("stand")) {
                                if(pressedKeys["39"] && !pressedKeys["37"]) {
                                    if((this.facing == 1 && this.state == "stand.walk") || this.state == "stand.idle") {
                                        this.builtSpeed++;
                                        this.xvel += 0.2;
                                        this.state = "stand.walk";
                                    } else {
                                        if(this.builtSpeed >= 25 || (this.xvel < 3 * turnaround && this.state == "stand.turn" && this.facing == 1)) {
                                            // LATER! Add particles and maybe change the turny requirement
                                            this.state = "stand.turn";
                                            this.xvel += turnaround;
                                            if(this.xvel >= 3 * turnaround) {
                                                this.state == "stand.walk";
                                                this.xvel = this.facing * 5;
                                            }
                                        } else {
                                            // Just turn around normally
                                            this.xvel += 0.5;
                                            this.lgp = [5, 35];
                                            this.state = "stand.walk";
                                        }
                                        this.builtSpeed = 0;
                                    }
                                    if(this.state == "stand.turn" && pressedKeys["90"]) {
                                        this.goalAngle = 360;
                                        this.xvel = 6;
                                        this.yvel = -9;
                                        this.state = "fall.idle";
                                        this.backflipping = true;
                                    }
                                    this.facing = 1;
                                } else if(pressedKeys["37"]) {
                                    if((this.facing == -1 && this.state == "stand.walk") || this.state == "stand.idle") {
                                        this.builtSpeed++;
                                        this.xvel -= 0.2;
                                        this.state = "stand.walk";
                                    } else {
                                        if(this.builtSpeed >= 25 || (this.xvel > -3 * turnaround && this.state == "stand.turn" && this.facing == -1)) {
                                            // LATER! Add particles and maybe change the turny requirement
                                            this.state = "stand.turn";
                                            this.xvel -= turnaround;
                                            if(this.xvel <= -3 * turnaround) {
                                                this.state == "stand.walk";
                                                this.xvel = this.facing * 5;
                                            }                                            
                                        } else {
                                            // Just turn around normally
                                            this.xvel -= 0.5;
                                            this.lgp = [5, 35];
                                            this.state = "stand.walk";
                                        }
                                        this.builtSpeed = 0;
                                    }
                                    if(this.state == "stand.turn" && pressedKeys["90"]) {
                                        this.goalAngle = -360;
                                        this.xvel = -6;
                                        this.yvel = -9;
                                        this.state = "fall.idle";
                                        this.backflipping = true;
                                    }
                                    this.facing = -1;
                                } else {
                                    // Not moving either right or left
                                    this.state = "stand.idle";
                                    this.xvel *= 0.8;
                                    this.builtSpeed *= 0.9;
                                    // Stop walking
                                    this.lgp = [5, 35];
                                }
                                if(pressedKeys["90"]) {
                                    // Jump
                                    if(!this.backflipping) this.yvel = -6;
                                    this.state = "fall.idle";
                                    this.builtSpeed = 0;
                                }
                                if(pressedKeys["40"] && !pressedKeys["38"]) {
                                    // Crouch
                                    this.state = "crouch.idle";
                                    this.agpx = [50 * this.facing, 150 * this.facing];
                                }
                                
                                // Angling
                                if(!this.backflipping) {this.goalAngle = 0; this.topGoalAngle = 0;}
                            } else if(this.in("fall")) {
                                if(pressedKeys["90"] && newKeys.includes(90) && this.state == "fall.slide") {
                                    // Wall jump
                                    this.yvel = -4;
                                    this.xvel = this.facing * -4;
                                    this.builtSpeed = 0;
                                }
                                if(pressedKeys["39"] && !pressedKeys["37"]) {
                                    this.facing = 1;
                                    this.xvel += 0.05;
                                    this.state = "fall.drift";
                                } else if(pressedKeys["37"]) {
                                    this.facing = -1;
                                    this.xvel -= 0.05;
                                    this.state = "fall.drift";
                                } else if(!this.contact()) {
                                    this.state = "fall.idle";
                                }
                                
                                /*if(Math.abs(this.goalAngle) == 90 && pressedKeys["38"]) {
                                    this.goalAngle = 0;
                                }
                                if(pressedKeys["40"] && !pressedKeys["38"]) {
                                    this.goalAngle = 90 * this.facing;
                                }*/
                                
                                this.lgp = ((pressedKeys["39"] || pressedKeys["37"]) ? [5 - this.facing * 10, 30 - this.facing * 10] : [5, 35]);
                            } else if(this.in("crouch")) {
                                this.ypos -= 50;
                                let canStandUp = !this.contact();
                                this.ypos += 50;
                                // Crawling
                                if(pressedKeys["39"] && !pressedKeys["37"]) {
                                    if((this.state == "crouch.idle" || this.state == "crouch.crawl") && this.facing == -1) {
                                        if(canStandUp) {
                                            this.state = "crouch.turn";
                                            this.agpx = [10, 30];
                                            this.facing = 1;
                                        } //else alert("turn right BLOCKED!");
                                        // LATER! If you can't stand up, maybe try turning
                                    } else if(this.state == "crouch.idle" || (this.facing == 1 && this.state == "crouch.crawl")) {
                                        // Move forward
                                        this.state = "crouch.crawl";
                                        this.builtSpeed++;
                                        this.facing = 1;
                                        if(pressedKeys["40"]) { this.xvel += 0.05; } else { this.xvel += 0.1; }
                                    }
                                } else if(pressedKeys["37"]) {
                                    if((this.state == "crouch.idle" || this.state == "crouch.crawl") && this.facing == 1) {
                                        if(canStandUp) {
                                            this.state = "crouch.turn";
                                            this.agpx = [10, 30];
                                            this.facing = -1;
                                        } //else alert("turn left BLOCKED!");
                                        // LATER! If you can't stand up, maybe try turning
                                    } else if(this.state == "crouch.idle" || this.state == "crouch.crawl") {
                                        // Move forward
                                        this.state = "crouch.crawl";
                                        this.builtSpeed++;
                                        this.facing = -1;
                                        if(pressedKeys["40"]) { this.xvel -= 0.05; } else { this.xvel -= 0.1; }
                                    }
                                    this.facing = -1;
                                } else {
                                    // Slow down
                                    this.xvel *= 0.8;
                                    this.builtSpeed = 0;
                                }
                                
                                if(this.state != "crouch.climb") { // Standing up & charge pounces don't happen in climbstate
                                    if(pressedKeys["38"] && canStandUp) {
                                        this.goalAngle = 0;
                                        this.state = "stand.idle";
                                    }
                                    if(pressedKeys["90"]) {
                                        // Charge???
                                        this.pounceCharge++;
                                    } else if(this.pounceCharge > 60) {
                                        this.pounceCharge = 0;
                                        // Leap!
                                        this.state = "fall.idle";
                                        // HUGE speed, but it'll decay fast
                                        this.xvel = this.facing * 15;
                                        this.yvel = -8;
                                        this.builtSpeed = 0;
                                    } else if(this.pounceCharge) {
                                        this.pounceCharge = 0;
                                        // A little hop
                                        this.yvel = -4;
                                        this.state = "fall.idle";
                                        this.builtSpeed = 0;
                                    }
                                    this.topGoalAngle = this.facing * (this.pounceCharge >= 60 ? 10 : 0);
                                }
                                
                                // Stop being in this climb up position?
                                if(this.state == "crouch.climb" && Math.abs(this.topAngle) < 50) {
                                    this.state = "crouch.idle";
                                    // Often, this will cause you to fall back off the ledge you climbed up, so correct this
                                    this.xvel = this.facing * 8;
                                }
                                
                                // Begin the standing-up process
                                if(Math.abs(this.topGoalAngle) > 10) {
                                    //alert("STAND UP");
                                    this.topGoalAngle = 0;
                                    this.goalAngle = this.facing * 90;
                                }
                                
                                if(this.state == "crouch.climb") {
                                    // Tick down
                                    // Prevent accelerating backward
                                    this.xvel = this.facing * 3;
                                    if(this.contact()) this.ypos -= 5;
                                    //this.goalAngle = 0;
                                } else if(Math.abs(this.topAngle) < 10) {
                                    // Angling
                                    this.goalAngle = this.facing * (this.pounceCharge >= 60 ? 80 : 90);
                                }
                                if(this.state == "crouch.turn" && this.facing * 90 == this.angle) {
                                    this.state = "crouch.idle";
                                    this.agpx = [50 * this.facing, 150 * this.facing];
                                }
                            } else if(this.in("climb")) {
                                this.goalAngle = 0;
                                this.yvel *= 0.9;
                                if(pressedKeys["38"] && !pressedKeys["40"]) {
                                    this.yvel -= 0.3;
                                    this.state = "climb.climb";
                                    this.facing = 1; // Not really "facing", but whatever
                                    this.builtSpeed++;
                                } else if(pressedKeys["40"]) {
                                    this.yvel += 0.3;
                                    this.state = "climb.climb";
                                    this.facing = -1; // Not really "facing", but whatever
                                    this.builtSpeed++;
                                } else {
                                    this.state = "climb.idle";
                                    this.builtSpeed = 0;
                                }
                                if(pressedKeys["39"] && newKeys.includes(39) && this.climbSide == -1) {
                                    // Flip to the right
                                    this.climbSide = 1;
                                    this.xpg = this.myPole.other + 5;
                                    this.lgp = [-10, 0];
                                } else if(pressedKeys["37"] && newKeys.includes(37) && this.climbSide == 1) {
                                    // Flip to the left
                                    this.climbSide = -1;
                                    this.xpg = this.myPole.other - 40;
                                    this.lgp = [35, 45];
                                }
                                if(pressedKeys["90"]) {
                                    if(pressedKeys["38"] && !pressedKeys[(38 + this.climbSide).toString()]) {
                                        if(!this.poleBoost) {
                                            this.poleBoost = 40;
                                            this.yvel = -10;
                                        }
                                    } else {
                                        // Polejump
                                        this.stopGrab = 20;
                                        alert("pjump");
                                        this.state = "fall.idle";
                                        this.xpg = 0;
                                        this.ypg = 0;
                                        this.yvel = -6;
                                        if(pressedKeys["37"] && this.climbSide == -1) this.xvel = -4;
                                        else if(pressedKeys["39"] && this.climbSide == 1) this.xvel = 4;
                                        else {this.xvel = 0; if(pressedKeys["40"]) {this.yvel = 1;} else {this.yvel = -1;}}
                                    }
                                }
                            } else if(this.in("balance")) {
                                if(pressedKeys["39"] && !pressedKeys["37"]) {
                                    this.facing = 1;
                                    this.state = "balance.lean";
                                    this.goalAngle += 2;
                                    this.builtSpeed++;
                                } else if(pressedKeys["37"]) {
                                    this.facing = -1;
                                    this.state = "balance.lean";
                                    this.goalAngle -= 2;
                                    this.builtSpeed++;
                                } else {
                                    // Not moving either right or left
                                    this.state = "balance.idle";
                                    this.goalAngle *= 0.8;
                                    this.builtSpeed *= 0.9;
                                }
                                this.goalAngle *= 0.95;
                                // Now set agpx and agpy based on the rotatey stuff
                                let one = rotate(this.body["armLS"].xpos, this.body["armLS"].ypos, -30, 30, this.angle);
                                let too = rotate(this.body["armRS"].xpos, this.body["armRS"].ypos, 70, 30, this.angle);
                                let len1 = Math.sqrt(
                                    (one[0]-this.body["armLS"].xpos)*(one[0]-this.body["armLS"].xpos) +
                                    (one[1]-this.body["armLS"].ypos)*(one[1]-this.body["armLS"].ypos)
                                );
                                one[0] = ((one[0] - this.body["armLS"].xpos) * (40 / len1)) + this.body["armLS"].xpos;
                                one[1] = ((one[1] - this.body["armLS"].ypos) * (40 / len1)) + this.body["armLS"].ypos;
                                let len2 = Math.sqrt(
                                    (too[0]-this.body["armRS"].xpos)*(too[0]-this.body["armRS"].xpos) +
                                    (too[1]-this.body["armRS"].ypos)*(too[1]-this.body["armRS"].ypos)
                                );
                                too[0] = ((too[0] - this.body["armRS"].xpos) * (40 / len2)) + this.body["armRS"].xpos;
                                too[1] = ((too[1] - this.body["armRS"].ypos) * (40 / len2)) + this.body["armRS"].ypos;
                                this.agpx = [one[0], too[0]];
                                this.agpy = [one[1], too[1]];
                                // I don't remember what this code does. :monkconfused:
                                
                                // Fall off the pole?
                                if(Math.abs(this.angle) > 36 || pressedKeys["90"]) {
                                    alert("falloff");
                                    this.state = "fall.idle";
                                    this.stopGrab = 30;
                                    this.xpg = 0;
                                    this.ypg = 0;
                                    this.goalAngle = 0;
                                    // Add'l stuff if you jumped off
                                    if(pressedKeys["90"]) {
                                        this.yvel = -6;
                                        if(pressedKeys["37"] && this.facing == -1) this.xvel = -4;
                                        else if(pressedKeys["39"] && this.facing == 1) this.xvel = 4;
                                        else {this.xvel = 0; this.yvel = -1;}
                                    } else this.xvel = this.facing * 1;
                                }
                            } else if(this.in("roll")) {
                                // Rolling is complicated.
                                if(!this.goalAngle && !this.angle) {
                                    this.state = "stand.idle";
                                    this.ypos -= 20;
                                }
                                this.xvel = this.facing * (this.noFall ? 3 : 1); // Maintain
                            }
                            // END CONTROLS CHECK
                            
                            // I didn't want to bother writing `this.myPole = null` all the time
                            if(!this.in("climb") && !this.in("balance")) this.myPole = null;
                            // And this check
                            if(!this.in("roll")) this.noFall = false;
                            
                            // Poles!
                            if(pressedKeys["38"] && (this.in("fall") || this.in("stand")) && !this.stopGrab) {
                                for(let p of this.room.poles.filter(x => x.dir == "v")) { // LARGE! Horizontal poles
                                    if(this.onPole(p)) {
                                        this.myPole = p;
                                        // Apply some initial y velocity to keep from just standing back up
                                        this.yvel = -3;
                                        // Stop xvel
                                        this.xvel = 0;
                                        this.state = "climb.idle";
                                        // Snap
                                        if((this.xpos + 20) > p.other) {
                                            this.climbSide = 1;
                                            this.xpos = p.other + 5;
                                        } else {
                                            this.climbSide = -1;
                                            this.xpos = p.other - 40;
                                        }
                                        // Arms up! Legs in!
                                        this.agpy = [-40, -20];
                                        this.lgp = (this.climbSide == 1 ? [-10, 0] : [35, 45]);
                                    }
                                }
                            }
                            
                            // I didn't want to bother writing `this.myPole = null` all the time... but I'm doing it again anyway
                            if(!this.in("climb") && !this.in("balance")) this.myPole = null;
                            
                            // Stun timer
                            if(this.stunTime) {
                                this.goalAngle = this.facing * 90;
                                this.stunTime = Math.max(0, this.stunTime - 1);
                                if(!this.stunTime) this.state = "stun.recover";
                            } else if(this.state == "stun.recover") {
                                this.goalAngle = 0;
                                if(!this.angle) this.state = "stand.idle";
                            }
                            
                            // Tilt
                            if((this.in("stand") || (Math.abs(this.angle) < 70 && this.in("fall") && this.state != "fall.slide")) && !this.colliding) {
                                this.btgp += 5 * this.xvel;
                            }
                            
                            // Horizontal movement
                            this.xpos += this.xvel;
                            if(this.noFall) this.ypos -= 50;
                            if(this.contact() && this.state != "crouch.climb") {
                                //alert("Xvel contact.");
                                // Try to just walk upwards
                                let checks = 0;
                                let xc = -0.1, yc = -0.4;
                                while(checks < 10 && this.contact() && !this.in("fall")) { // No, you can't WALK up while FALLING
                                    this.xpos += xc * this.xvel;
                                    this.ypos += yc * Math.abs(this.xvel);
                                    checks++;
                                }
                                if(checks == 10 || this.in("fall")) {
                                    // Aww... Undo that
                                    this.xpos -= this.xvel;
                                    this.ypos -= yc * checks * Math.abs(this.xvel);
                                    this.xpos -= xc * checks * this.xvel;
                                    if(this.in("stand")) {
                                        if(this.xvel > 0) {
                                            this.lgp = [25, 35];
                                        } else {
                                            this.lgp = [5, 15];
                                        }
                                    }
                                    // Wall sliding - reduce yvel & put into WS state
                                    if(this.in("fall") && ((pressedKeys["39"] && this.xvel > 0) || (pressedKeys["37"] && this.xvel < 0))) {
                                        let toTop = 0;
                                        this.xpos += this.xvel; // Go back into the wall
                                        while(toTop < 150 && this.contact()) {
                                            this.ypos -= 10; toTop += 10;
                                        }
                                        if(toTop < 50 && !this.contact(false)) {
                                            // Climbing up
                                            this.state = "crouch.climb";
                                            this.climbTime = 20;
                                            this.topGoalAngle = this.facing * 90;
                                            this.topAngle = this.topGoalAngle;
                                            this.xpos -= 1 * this.xvel;
                                            this.ypos -= 20;
                                            this.yvel = 0;
                                            this.xvel = 0;
                                        } else {
                                            this.ypos += toTop; this.xpos -= this.xvel; // Undo that
                                            this.state = "fall.slide";
                                            this.yvel *= 0.75;
                                            this.colliding = 5; // Stop BTGP for a few frames
                                            let b = this.btgp;
                                            this.btgp = 0;
                                            if(this.contact()) {
                                                this.xpos -= b;
                                            }
                                        }
                                    }
                                    if(this.in("roll")) {
                                        if(this.contact()) {
                                            this.state = "stand.idle";
                                            this.xpos -= 10 * this.xvel;
                                            this.ypos -= 20;
                                            this.angle = 0;
                                            this.goalAngle = 0;
                                        }
                                    }
                                    this.xvel *= 0.8;
                                }
                            } else { this.colliding = Math.max(0, this.colliding - 1); }
                            if(this.noFall) this.ypos += 50;
                            if(this.stopGrab) this.stopGrab--;
                            // Horizontal friction
                            if(this.in("roll")) this.xvel *= 1.00; // conservation of momentum
                            else if(this.in("fall")) this.xvel *= 0.98;
                            else this.xvel *= 0.95;
                            
                            // Yvel check: when moving upwards, cancel if jump isn't held
                            if(this.yvel < 0 && !pressedKeys["90"] && !this.in("climb") && !this.backflipping) this.yvel *= 0.9;
                            // Another yvel check: pole boosting
                            if(this.poleBoost) {
                                this.poleBoost--;
                                if(this.poleBoost > 5 && this.poleBoost < 25) this.yvel *= 0.8;
                            }
                            
                            // Vertical movement
                            this.ypos += this.yvel + 3;
                            if(this.contact() && this.in("fall")) {
                                //alert("We do be contact.");
                                if(this.backflipping) {
                                    this.backflipping = false;
                                    this.xvel = 0;
                                }
                                // idk why this whole thing exists
                                let obj = this.contact();
                                let top = (obj instanceof Rectangle ? obj.ypos : null);
                                // I'm willing to use this approximation (the global bottom of the polygon rather than the local one)
                                let bottom = (this.getHitbox() instanceof Rectangle ? (this.getHitbox().ypos + this.getHitbox().height) : this.getHitbox() instanceof Polygon ? this.getHitbox().dims().bottom : null);
                                // Make sure the distance is reasonable -- no large teleports upward
                                if(top && bottom) {
                                    if(bottom - top < 30) {
                                        this.ypos -= (bottom - top);
                                    } else {
                                        this.ypos -= this.yvel;
                                    }
                                } else {
                                    this.ypos -= this.yvel;
                                }
                                let roll = (this.facing == -1 ? pressedKeys["37"] : pressedKeys["39"]) && pressedKeys["40"];
                                if(this.yvel > 9000 || (this.yvel > 8099 && !roll)) {
                                    // I gotta actually implement stunning before this is useful
                                    this.stun((this.yvel - 6789) * 20);
                                } else if(this.yvel > 7 && roll) {
                                    // Roll
                                    this.state = "roll.roll"; // idk what to call this
                                    this.ypos += 5;
                                    this.goalAngle = this.facing * 720;
                                    //this.xvel = this.facing * 5; // LATER! Tweak this speed to make it better
                                } else if(this.state != "fall.slide" && !this.in("crouch")) {
                                    // Just move around a little to make sure nothing weird is happening
                                    let c1 = this.contact();
                                    this.xvel += this.facing * 3;
                                    let c = this.contact();
                                    this.xvel -= this.facing * 3;
                                    //alert("Ouch! c1="+c1+" c="+c);
                                    if(!c1 && !c) {
                                        this.backflipping = false;
                                        if(Math.abs(this.angle) > 70 || this.state == "crouch.climb") {
                                            this.state = "crouch.idle";
                                            this.agpx = [50 * this.facing, 150 * this.facing];
                                        } else {
                                            this.state = "stand.idle";
                                        }
                                    }
                                } else if(this.state == "fall.slide") {
                                    // You probably just slid down to the ground
                                    this.state = "stand.idle";
                                }
                                this.yvel = 0;
                            } else if(this.in("fall")) {
                                this.yvel += 0.2; // Gravity
                            } else if(this.in("climb")) {
                                if(this.myPole.dir == "v" && (this.ypos + 10) < this.myPole.start) {
                                    // Balance on the pole
                                    this.state = "balance.idle";
                                    this.xpg = (this.myPole.other - 20);
                                    this.ypg = (this.myPole.start - 80);
                                    // Set legs & arms
                                    this.lgp = [10, 30];
                                    this.agpx = [-30, 70];
                                    this.agpy = [30, 30];
                                    this.xvel = 0;
                                    this.yvel = 0;
                                }
                            }
                            // Did you just walk off the edge
                            this.ypos += 3;
                            // While noFall is active, make this harder to activate, but not impossible
                            if(this.noFall) this.ypos += 5;
                            if(!this.contact() && !this.in("fall") && !this.in("climb") && !this.in("balance") && this.state != "crouch.climb") {
                                //alert("ouch... state="+this.state);
                                this.state = "fall.idle";
                                this.builtSpeed = 0;
                                if(this.noFall) {
                                    this.ypos -= 90; this.noFall = false;
                                }
                            }
                            if(this.noFall) this.ypos -= 5;
                            this.ypos -= 6;
                            
                            // Climbing down to the bottom of a pole
                            if(this.contact() && this.in("climb")) {
                                this.state = "stand.idle";
                                this.yvel = -5;
                                this.ypos += 2 * this.yvel;
                                this.xpg = 0;
                            }
                            
                            // Changing angle
                            if(this.angle > 180) {this.angle -= 360; this.goalAngle -= 360;}
                            if(this.angle < -180) {this.angle += 360; this.goalAngle += 360;}
                            
                            let speed = (this.in("stun") ? 10 : this.backflipping ? 8 : 5); // <-- why does this stun part exist?
                            if(this.climbTime) {this.climbTime--; speed += 5;} // Go faster just after climbing
                            let oa = this.angle;
                            let finished = this.angle == this.goalAngle;
                            let was = this.contact();
                            if(this.angle < this.goalAngle) {
                                this.angle = Math.min(this.goalAngle, this.angle + speed);
                            } else {
                                this.angle = Math.max(this.goalAngle, this.angle - speed);
                            }
                            if(this.contact() && !finished) {
                                //alert("Hey!");
                                if(this.in("stand") && Math.abs(this.angle) > 30) {
                                    // You probably tried to stand up when you really shouldn't have, get back down there!
                                    this.goalAngle = 90 * (this.angle > 0 ? 1 : -1);
                                    this.angle = this.goalAngle;
                                    this.state = "crouch.idle";
                                    //alert("Go back from whence you came!");
                                } else if(!this.in("roll")) {
                                    this.angle = oa + (this.angle > 0 ? -5 : 5);
                                    //this.goalAngle = 0;
                                    this.xvel = this.facing * -4;
                                    this.xpos += this.xvel;
                                }
                            }
                            
                            // Top angle is much the same
                            let tspeed = 20;
                            let toa = this.topAngle;
                            let tfinished = this.topAngle == this.topGoalAngle;
                            let twas = this.contact();
                            if(this.topAngle < this.topGoalAngle) {
                                this.topAngle = Math.min(this.topGoalAngle, this.topAngle + tspeed);
                            } else {
                                this.topAngle = Math.max(this.topGoalAngle, this.topAngle - tspeed);
                            }
                            if(this.contact() && !tfinished) {
                                this.topAngle = toa;
                                //this.xvel = this.facing * -4;
                                this.xpos += this.xvel;
                            }
                            
                            if(this.in("roll") && this.facing == 1 && this.angle == 90 && this.goalAngle >= 360 && !this.noFall) {
                                //alert("rolly");
                                this.xpos += 70;
                                this.ypos += 40;
                                this.noFall = true;
                            } else if(this.noFall && this.facing == 1 && this.angle == -90) {
                                //alert("rollBACK");
                                this.noFall = false;
                                this.xpos += 50;
                                this.ypos -= 40;
                            }
                            if(this.in("roll") && this.facing == -1 && this.angle == -90 && this.goalAngle <= -360) {
                                //alert("rollyLLLL");
                                this.xpos -= 70;
                                this.ypos += 40;
                                this.noFall = true;
                            } else if(this.noFall && this.facing == -1 && this.angle == 90) {
                                //alert("rollBACK_LLLL");
                                this.noFall = false;
                                this.xpos -= 50;
                                this.ypos -= 40;
                            }
                            
                            if(!this.angle && this.backflipping) this.backflipping = false;
                            
                            let cx = (this.backflipping ? 20 : (this.angle > 0 ? 35 : 5));
                            let cy = (this.backflipping ? 35 : 90);
                            let cx2 = (this.topAngle > 0 ? 35 : 5);
                            let cy2 = 35;
                            
                            /*circle([this.body.bodyML.REAL_xpos + this.xpos, this.body.bodyML.REAL_ypos + this.ypos], 5, "pink");
                            circle([this.body.bodyMR.REAL_xpos + this.xpos, this.body.bodyMR.REAL_ypos + this.ypos], 5, "green");
                            circle([this.body.bodyTL.REAL_xpos + this.xpos, this.body.bodyTL.REAL_ypos + this.ypos], 5, "blue");
                            circle([this.body.bodyTR.REAL_xpos + this.xpos, this.body.bodyTR.REAL_ypos + this.ypos], 5, "yellow");*/
                            
                            // Sometimes the mid body segments get screwed up
                            if(Math.abs(this.topAngle) < 1 && !this.topGoalAngle) {
                                this.body.bodyML.ypos = 35;
                                this.body.bodyMR.ypos = 35;
                            }
                            
                            if(this.noFall) {cx = 20; cy = 20;}
                            for(let i of Object.values(this.body)) {i.cx = cx; i.cy = cy; i.secondCx = cx2; i.secondCy = cy2;}
                            
                            // Moving forward - make the legs move back, then check if they need to be moved forward
                            if(this.state == "stand.walk") {
                                this.lgp[0] -= this.xvel;
                                this.lgp[1] -= this.xvel;
                                if(this.facing == 1) {
                                    if(this.lgp[0] <= -20) this.lgp[0] = 60;
                                    if(this.lgp[1] <= -20) this.lgp[1] = 60;
                                } else {
                                    if(this.lgp[0] >= 60) this.lgp[0] = -20;
                                    if(this.lgp[1] >= 60) this.lgp[1] = -20;
                                }
                            } else if(this.state == "stand.turn") {
                                if(this.facing == 1) {
                                    this.lgp[0] = -20;
                                    this.lgp[1] = 10;
                                } else {
                                    this.lgp[0] = 30;
                                    this.lgp[1] = 60;
                                }
                            }
                            
                            // For crouching, "walk" with the arms
                            if(this.state == "crouch.crawl") { // Weird name but ok
                                this.agpx[0] -= this.xvel;
                                this.agpx[1] -= this.xvel;
                                if(this.facing == 1) {
                                    if(this.agpx[0] <= 100) this.agpx[0] = 160;
                                    if(this.agpx[1] <= 100) this.agpx[1] = 160;
                                } else {
                                    if(this.agpx[0] >= -60) this.agpx[0] = -120;
                                    if(this.agpx[1] >= -60) this.agpx[1] = -120;
                                }
                            }
                            // And make sure the arms aren't weirdly in the air
                            if(this.in("crouch")) this.agpy = [Math.abs(this.angle), Math.abs(this.angle)];
                            
                            // Climbing - do the same as above, but upwards
                            if(this.state == "climb.climb") { // Weird name but ok
                                this.agpy[0] -= this.yvel;
                                this.agpy[1] -= this.yvel;
                                if(this.facing == -1) { // Up
                                    if(this.agpy[0] <= -20) this.agpy[0] = 60;
                                    if(this.agpy[1] <= -20) this.agpy[1] = 60;
                                } else {
                                    if(this.agpy[0] >= 60) this.agpy[0] = -20;
                                    if(this.agpy[1] >= 60) this.agpy[1] = -20;
                                }
                            }
                            // Also do the X
                            if(this.in("climb")) {
                                if(this.climbSide == 1) {
                                    this.agpx = [-10, 0];
                                } else {
                                    this.agpx = [30, 40];
                                }
                            }
                            
                            // Change mid body when the second angle is set, so they don't look too weird
                            if(this.topAngle > 0) {
                                let adj = this.topAngle;
                                if(adj < 45) adj += 2 * (45 - adj);
                                let squished = 90 - 0.5 * (90 - adj);
                                let cosine = Math.cos(squished * Math.PI / 180);
                                this.body.bodyML.ypos = cosine * 0.8;
                            } else if(this.topAngle < 0) {
                                let adj = -1 * this.topAngle;
                                if(adj < 45) adj += 2 * (45 - adj);
                                let squished = 90 - 0.5 * (90 - adj);
                                let cosine = Math.cos(squished * Math.PI / 180);
                                this.body.bodyMR.ypos = cosine * 0.8;
                            }
                            
                            
                            // It would look a little weird if I just hid the arms, so I'll do this instead
                            if((!this.in("crouch") || this.state == "crouch.climb") && !this.in("climb") && !this.in("balance")) {
                                this.agpx = [20 + this.btgp * 1, 20 + this.btgp * 1];
                                this.agpy = [30, 30];
                            }
                            
                            // Now use `this.lgp`, `this.agpx`, `this.agpy`, and `this.btgp` to move the actual stuff
                            if(!this.contact()) {
                                this.body.legLE.xpos += 0.1 * (this.lgp[0] - this.body.legLE.xpos);
                                if(this.contact()) this.body.legLE.xpos -= 0.1 * (this.lgp[0] - this.body.legLE.xpos);
                            }
                            if(!this.contact()) {
                                this.body.legRE.xpos += 0.1 * (this.lgp[1] - this.body.legRE.xpos);
                                if(this.contact()) this.body.legRE.xpos -= 0.1 * (this.lgp[1] - this.body.legRE.xpos);
                            }
                            
                            // AGP (X and Y)
                            this.body.armLE.xpos += 0.1 * (this.agpx[0] - this.body.armLE.xpos);
                            this.body.armRE.xpos += 0.1 * (this.agpx[1] - this.body.armRE.xpos);
                            this.body.armLE.ypos += 0.1 * (this.agpy[0] - this.body.armLE.ypos);
                            this.body.armRE.ypos += 0.1 * (this.agpy[1] - this.body.armRE.ypos);
                            
                            // BTGP
                            //this.topAngle = 80;
                            if((this.in("stand") || this.in("fall") || this.in("balance")) && Math.abs(this.angle) < 1 && Math.abs(this.topAngle) < 1) {
                                //alert("Here we go...");
                                this.body.bodyTL.xpos += 0.1 * (this.btgp + 5 - this.body.bodyTL.xpos);
                                this.body.bodyTR.xpos += 0.1 * (this.btgp + 35 - this.body.bodyTR.xpos);
                                this.body.bodyML.xpos += 0.1 * (0.5 * this.btgp + 5 - this.body.bodyML.xpos);
                                this.body.bodyMR.xpos += 0.1 * (0.5 * this.btgp + 35 - this.body.bodyMR.xpos);
                                this.body.earLS.xpos += 0.1 * (this.btgp + 5 - this.body.earLS.xpos);
                                this.body.earLE.xpos += 0.1 * (this.btgp + 5 - this.body.earLE.xpos);
                                this.body.earRS.xpos += 0.1 * (this.btgp + 35 - this.body.earRS.xpos);
                                this.body.earRE.xpos += 0.1 * (this.btgp + 35 - this.body.earRE.xpos);
                                this.body.eyeL.xpos += 0.1 * (this.btgp + 9 - this.body.eyeL.xpos);
                                this.body.eyeR.xpos += 0.1 * (this.btgp + 31 - this.body.eyeR.xpos);
                                this.body.nouth.xpos += 0.1 * (this.btgp + 20 - this.body.nouth.xpos);
                            } else {
                                // Clear out BTGP
                                this.body.bodyTL.xpos += this.btgp + 5 - this.body.bodyTL.xpos;
                                this.body.bodyTR.xpos += this.btgp + 35 - this.body.bodyTR.xpos;
                                this.body.bodyML.xpos += 0.5 * this.btgp + 5 - this.body.bodyML.xpos;
                                this.body.bodyMR.xpos += 0.5 * this.btgp + 35 - this.body.bodyMR.xpos;
                                this.body.earLS.xpos += this.btgp + 5 - this.body.earLS.xpos;
                                this.body.earLE.xpos += this.btgp + 5 - this.body.earLE.xpos;
                                this.body.earRS.xpos += this.btgp + 35 - this.body.earRS.xpos;
                                this.body.earRE.xpos += this.btgp + 35 - this.body.earRE.xpos;
                                this.body.eyeL.xpos += this.btgp + 9 - this.body.eyeL.xpos;
                                this.body.eyeR.xpos += this.btgp + 31 - this.body.eyeR.xpos;
                                this.body.nouth.xpos += this.btgp + 20 - this.body.nouth.xpos;
                            }
                            
                            let df = (this.xpg ? 0.3 * (this.xpg - this.xpos) : 0);
                            this.xpos += df;
                            // What did df stand for again?
                            let dg = (this.ypg ? 0.3 * (this.ypg - this.ypos) : 0);
                            this.ypos += dg;
                            this.df2 -= 0.05 * (this.df2 - df);
                            
                            // Angle stuff
                            //this.angle = 0;
                            let partsToTurn = ["bodyTL", "bodyTR", "bodyML", "bodyMR", "earLS", "earLE", "armLS", "armRS", "earRS", "earRE", "eyeL", "eyeR", "nouth", "legLS", "legRS"];
                            if(this.backflipping) {partsToTurn.push("legLE"); partsToTurn.push("legRE");}
                            for(let i of partsToTurn) {
                                this.body[i].angle = this.angle;
                            }
                            for(let i of Object.keys(this.body).filter(x=>!partsToTurn.includes(x))) {
                                this.body[i].angle = 0;
                            }
                            // Add topAngle to the upper parts
                            // Ohh this is tricky... the rotation direction needs to be changed
                            for(let i of ["bodyTL", "bodyTR", "earLS", "earLE", "earRS", "earRE", "eyeL", "eyeR", "nouth"]) {
                                this.body[i].secondAngle = this.topAngle;
                            }

                            // Tail
                            if(!this.tail.length) this.tail = [[20, 60]];
                            for(let i=1; i<15; i++) {
                                if(this.tail.length <= i) this.tail.push(this.tail[i - 1]);
                                let otx = this.tail[i-1][0], oty = this.tail[i-1][1], tx = this.tail[i][0] - otx, ty = this.tail[i][1] - oty;
                                
                                tx += 3 * this.df2;
                                tx -= this.btgp;
                                // When crouching, weird stuff can happen sometimes
                                if(this.in("crouch") || Math.abs(this.angle) > 50) {
                                    tx -= 10 * this.facing;
                                    ty += 1;
                                } else ty += 8;
                                // This makes it look better, trust me
                                if(!this.backflipping) ty -= this.yvel * 3;
                                // Backflip override
                                if(this.backflipping) {
                                    tx = -10 * Math.sin((10 * i + this.angle) * Math.PI / 180);
                                    ty = 10 * Math.cos((10 * i + this.angle) * Math.PI / 180);
                                }
                                
                                let dx = otx + tx + this.xpos, dy = oty + ty + this.ypos, MAXDIST = 10 - 0.5 * i;
                                // Set `ignoreUUIDs` to `this` so the tail doesn't collide with the rest of the body
                                while(new Hitbox(new Rectangle(dx - MAXDIST, dy - MAXDIST, MAXDIST * 2, MAXDIST * 2), [this.uuid]).contact()) {
                                    ty -= 1;
                                    tx -= this.facing;
                                    // Recalc!
                                    dx = otx + tx + this.xpos; dy = oty + ty + this.ypos;
                                }
                                
                                let dist = Math.sqrt(tx*tx + ty*ty);
                                if(dist > MAXDIST) {
                                    tx /= (dist / MAXDIST);
                                    ty /= (dist / MAXDIST);
                                }
                                this.tail[i] = [otx + tx, oty + ty];
                            }
                            //this.btgp = 0; // Add this later; but I want to be logging it for now!
                        }
                    );
                    
                    this.lgp = [5, 35]; // Leg Goal Pos - where I want to put the legs
                    this.agpx = [10, 30]; // Arm Goal Pos - where I want to put the arms
                    this.agpy = [0, 0]; // same, but for Y position
                    this.xpg = 0; // X position goal
                    this.ypg = 0; // Y position goal
                    this.btgp = 0; // Body Top Goal Pos
                    this.facing = 1; // 1 or -1
                    this.builtSpeed = 0; // How long you've been going in the current direction
                    this.tail = []; // Array of tail segments
                    this.angle = 0, this.goalAngle = 0; // Where you want to turn
                    this.topAngle = 0, this.topGoalAngle = 0; // Add'l angle added just to the top part
                    this.stunTime = 0; // How long until you're unstunned
                    this.colliding = 0; // Whether to stop BTGP due to a collision
                    this.myPole = null; // Pole you're currently climbing on
                    this.climbSide = 0; // Which side you're climbing on, only relevant while in climb
                    this.df2 = 0; // This is related to the tail somehow. Don't even try asking me what it stands for
                    this.stopGrab = 0; // Block regrabbing a pole you just jumped off
                    this.poleBoost = 0; // Boosting up poles
                    this.pounceCharge = 0; // Time spent holding Z in crouch
                    this.noFall = false; // Whether to restrict going into fall state; used when rolling
                    this.climbTime = 0; // I need to stop fast-stand when holding up and make up required to climb and reduce climb limit and fix not climbing sometimes and other climbing stuff
                    this.backflipping = false;
                }
                stun(time) {
                    this.state = "stun.idle";
                    this.stunTime = time;
                    // LATER! Drop what you're holding
                }
                doHands() {
                    if(!this.in("climb")) return;
                    // Put hands a layer above poles
                    circle(this.bodyCoords("armLE"), 5, "white");
                    circle(this.bodyCoords("armRE"), 5, "white");
                }
                get centerPos() {
                    return [this.bodyCoords("bodyTL")[0] + 0.5 * (this.bodyCoords("bodyTR")[0] - this.bodyCoords("bodyTL")[0]), this.bodyCoords("bodyTL")[1]];
                }
            }
            
            let SC, rooms = [], lizor;
            let slowdown = false;
            try {
                let startRoom = new Room(
                    // FG MG BG
                    [new Rectangle(1060, 50, 80, 250, "#633")],
                    [
                        new Rectangle(0, 20, 100, 380, "#363"),
                        new Rectangle(900, 160, 80, 240, "#343"),
                        new Rectangle(100, 320, 800, 80, "#393"),
                        new Rectangle(440, 480, 80, 120, "#363"),
                        new Rectangle(440, 600, 900, 80, "#363"),
                        new Rectangle(100, 480, 340, 80, "#363"),
                        //new Rectangle(900, 510, 80, 80, "#363")
                    ],
                    [new Rectangle(980, 50, 80, 250, "#336")],
                    // Poles: Start, end, other, dir
                    [new Pole(600, 620, 750, "v")]
                );
                rooms.push(startRoom);
                // Initialize player
                SC = new Player(startRoom, 120, 80);
                // Spawn a liz
                lizor = new PinkLizard(startRoom, 600, 450);
            } catch(e) { alert("Error in init: " + e); }
            
            function frame(globalTimer) { try {
                elapsedTime = globalTimer;
                ctx.clearRect(0, 0, 1350, 630);
                // LARGE! More rooms? More cameras? Scrolling!?
                SC.room.render();
                for(let i of rooms) {
                    for(let j of i.entities) { j.tick(); }
                }
                
                newKeys = [];
                
                // Test to make sure my contact code works
                //let gc = SC.room.grid[Math.floor(mousey / 10)][Math.floor(mousex / 10)];
                
                let tex = `<i>wetlands ${VERSION}</i> | lizor's stats -- state: ${lizor.state} contact: <span style="background:${lizor.contact() ? "red" : "blue"}">${lizor.contact() ? "yes" : "no"}</span> | your stats -- facing: ${SC.facing == 1 ? "right" : "left"} vel: (${SC.xvel.toFixed(1)},${SC.yvel.toFixed(1)}) pos: (${SC.xpos.toFixed(1)},${SC.ypos.toFixed(1)}) angle: <span style="background:${SC.angle == SC.goalAngle ? "blue" : "red"}">${SC.angle.toFixed(0)} (${SC.goalAngle.toFixed(0)})</span> + <span style="background:${SC.topAngle == SC.topGoalAngle ? "blue" : "red"}">${SC.topAngle.toFixed(0)} (${SC.topGoalAngle.toFixed(0)})</span> contact: <span style="background:${SC.contact() ? "red" : "blue"}">${SC.contact() ? "yes" : "no"}</span> tilt: <span style="background:${Math.abs(SC.btgp) > 1 ? "red" : "blue"}">${SC.btgp.toFixed(0)}</span> pole: <span style="background:${SC.myPole ? "red" : "blue"}">${SC.myPole ? "yes" : "no"}</span> nofall: <span style="background:${SC.noFall ? "red" : "blue"}">${SC.noFall ? "yes" : "no"}</span> fakevel: <span style="background:${Math.abs(SC.df2) > 0.1 ? "red" : "blue"}">${SC.df2.toFixed(1)}</span> climbtime: <span style="background:${SC.climbTime ? "red" : "blue"}">${SC.climbTime}</span> backflip: <span style="background:${SC.backflipping ? "red" : "blue"}">${SC.backflipping ? "yes" : "no"}</span> [${SC.DEBUGGO}] state: ${SC.state} inputs: ${Object.keys(pressedKeys).filter(x=>pressedKeys[x])}`;
                document.getElementById("sayer").innerHTML = tex;
                document.getElementById("sayer").style.fontSize = Math.floor(Math.min(16, 7500 / tex.length)) + "px";
                SC.btgp = 0; // Delete this later!
                
                if(SC.backflipping) slowdown = true;
                let DEL = slowdown ? 0 : 0;
                if(DEL) setTimeout(function() {window.requestAnimationFrame(frame)}, DEL);
                else window.requestAnimationFrame(frame);
            } catch(e) { alert("Error in frame(): " + e); } }

            document.addEventListener("keydown", function(e) {
                let k = e.keyCode;
                //alert("Key pressed: " + k);
            });
            document.onmousemove = function(e) {
                mousex = e.clientX;
                mousey = e.clientY;
            }
            function loaded() {
                ctx = document.getElementById("canv").getContext("2d");
                window.requestAnimationFrame(frame);
            }
        </script>
    </head>
    <body onload="loaded()">
        <div id="sayer">uh oh problemo</div>
        <canvas id="canv" width="1350" height="630"></canvas>
    </body>
</html>
