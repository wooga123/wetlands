<html>
    <head>
        <title>just a test</title>
        <style>
            html {
                background: #222;
                color: white;
            }
            canvas {
                background: #888;
            }
        </style>
        <script>
            const VERSION = "v0.0.1"; // It's gonna be awhile before this is relevant
            let ctx;
            
            let pressedKeys = {};
            window.onkeyup = function(e) { pressedKeys[e.keyCode] = false; }
            window.onkeydown = function(e) { pressedKeys[e.keyCode] = true; newKeys.push(e.keyCode); }
            
            // found on stackoverflow
            function rotate(centerx, centery, x, y, degrees) {
                var newx = (x - centerx) * Math.cos(degrees * Math.PI / 180) - (y - centery) * Math.sin(degrees * Math.PI / 180) + centerx;
                var newy = (x - centerx) * Math.sin(degrees * Math.PI / 180) + (y - centery) * Math.cos(degrees * Math.PI / 180) + centery;
                return [newx, newy];
            }
            
            function drawBody(t, l, r, c = "white") {
                ctx.lineWidth = r;
                ctx.fillStyle = c;
                ctx.lineCap = "round";
                for(let i=0; i<l.length; i++) {
                    line(t.bodyCoords(l[i]), t.bodyCoords(i + 1 == l.length ? l[0] : l[i + 1]));
                }
                ctx.beginPath();
                for(let i of l) {
                    ctx.lineTo(...t.bodyCoords(i));
                }
                ctx.fill();
            }
            function circle(p, r, c = "black", f = true) {
                if(f) {ctx.fillStyle = c;} else {ctx.strokeStyle = c;}
                ctx.beginPath();
                ctx.arc(...p, r, 0, 2 * Math.PI);
                if(f) {ctx.fill();} else {ctx.stroke();}
            }
            function line(p, q, c = "white") {
                ctx.strokeStyle = c;
                ctx.beginPath();
                ctx.moveTo(p[0], p[1]);
                ctx.lineTo(q[0], q[1]);
                ctx.stroke();
            }
            
            class Rectangle {
                constructor(x, y, w, h, c = "white", f = true) {
                    this.xpos = x;
                    this.ypos = y;
                    this.width = w;
                    this.height = h;
                    this.color = c;
                    this.fill = f;
                }
                render() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    if(this.fill) {ctx.fillRect(this.xpos, this.ypos, this.width, this.height);}
                    else {ctx.strokeRect(this.xpos, this.ypos, this.width, this.height);}
                }
                touches(other) {
                    if(other instanceof Rectangle) {
                        if(this.xpos + this.width > other.xpos && this.xpos < other.xpos + other.width &&
                           this.ypos + this.height > other.ypos && this.ypos < other.ypos + other.height) {
                            return true;
                        }
                    } else if(other instanceof Polygon || other instanceof Hitbox) {
                        // implemented in the other class
                        return other.touches(this);
                    }
                    return false;
                }
            }
            
            class Polygon {
                constructor(p, c = "white", f = true) {
                    this.points = p;
                    this.lines = p.map(function(x, i) {
                        let n = (i + 1 == p.length ? p[0] : p[i + 1]);
                        let d = {p1: x, p2: n, x1: x[0], y1: x[1], x2: n[0], y2: n[1]};
                        // 8th grade math is paying off!
                        d.length = Math.sqrt((d.y2 - d.y1) * (d.y2 - d.y1) + (d.x2 - d.x1) * (d.x2 - d.x1));
                        d.slope = (d.y2 - d.y1) / (d.x2 - d.x1);
                        d.yIntercept = d.y1 - d.x1 * d.slope;
                        return d;
                    });
                    this.color = c;
                    this.fill = f;
                }
                render() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(...this.points[0]);
                    for(let i of this.points.slice(1)) {
                        ctx.lineTo(...i);
                    }
                    if(this.fill) {ctx.fill();} else {ctx.closePath(); ctx.stroke();}
                }
                touches(other) {
                    if(other instanceof Rectangle) {
                        // Turn the rectangle into a polygon
                        let x2 = other.width + other.xpos;
                        let y2 = other.height + other.ypos;
                        return this.touches(new Polygon([
                            [other.xpos, other.ypos],
                            [other.xpos, y2],
                            [x2, y2],
                            [x2, other.ypos]
                        ]));
                    } else if(other instanceof Polygon) {
                        for(let i of this.lines) {
                            for(let j of other.lines) {
                                // grabbed this off stack overflow
                                let det, gamma, lambda;
                                let a = i.x1, b = i.y1, c = i.x2, d = i.y2;
                                let p = j.x1, q = j.y1, r = j.x2, s = j.y2;
                                det = (c - a) * (s - q) - (r - p) * (d - b);
                                if(det) {
                                    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
                                    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
                                    if((0 < lambda && lambda < 1) && (0 < gamma && gamma < 1)) return true;
                                }
                            }
                        }
                    } else if(other instanceof Hitbox) {
                        // implemented in the other class
                        return other.touches(this);
                    }
                    return false;
                }
                dims() {
                    let ys = this.points.map(x => x[1]).sort();
                    let xs = this.points.map(x => x[0]).sort();
                    return {top: ys[0], left: xs[0], right: xs[xs.length - 1], bottom: ys[ys.length - 1]};
                }
            }
            
            class Hitbox {
                // A group of shapes, handy for making hitboxes
                constructor(shapes) {
                    this.shapes = shapes;
                }
                touches(other) {
                    for(let i of this.shapes) {
                        if(i.touches(other)) return i;
                    }
                    return false;
                }
            }
            
            class Room {
                constructor(fg, mg, bg) {
                    // These are lists of polygons that get called to draw the room.
                    this.foreground = fg;
                    this.midground = mg;
                    this.background = bg;
                    this.hitbox = new Hitbox(mg);
                    // The entities in the room
                    this.entities = [];
                }
                render() {
                    for(let i of this.background) {i.render();}
                    for(let j of this.entities) {j.render();}
                    for(let l of this.midground) {l.render();}
                    for(let k of this.foreground) {k.render();}
                }
            }
            
            class Position {
                // A really simple class
                constructor(x, y, a=0, cx=0, cy=0, rx=0, ry=0) {
                    this.REAL_xpos = x;
                    this.REAL_ypos = y;
                    this.cx = cx;
                    this.cy = cy;
                    this.angle = a;
                    this.owner = null;
                }
                
                get xpos() {
                    return rotate(this.cx, this.cy, this.REAL_xpos, this.REAL_ypos, this.angle)[0];
                }
                set xpos(v) {this.REAL_xpos = v;}
                
                get ypos() {
                    return rotate(this.cx, this.cy, this.REAL_xpos, this.REAL_ypos, this.angle)[1];
                }
                set ypos(v) {this.REAL_ypos = v;}
            }
            
            class BasicEntity {
                constructor(n, r, x, y, s, b, g, re, t) {
                    this.name = n;
                    this.room = r;
                    r.entities.push(this);
                    this.xpos = x;
                    this.ypos = y;
                    this.state = s;
                    this.body = b;
                    for(let i of Object.values(this.body)) {
                        i.owner = this;
                    }
                    this.dead = false;
                    this.getHitbox = g;
                    this.render = re;
                    this.tick = t;
                }
                bodyCoords(b, xtrax = 0, xtray = 0) {
                    return [this.body[b].xpos + this.xpos + xtrax, this.body[b].ypos + this.ypos + xtray];
                }
                contact() {
                    return this.getHitbox().touches(this.room.hitbox);
                }
                in(state) {
                    return this.state.includes(state + ".");
                }
            }
            
            class Player extends BasicEntity {
                constructor(room) {
                    // Construct!
                    super(
                        // State determines key handling, hitboxes, and rendering
                        // Second part of state is more precise
                        "sc", room, 150, 50, "fall.idle",
                        // These are the OFFSETS not the ABSOLUTE positions
                        {
                            bodyTL: new Position(5, 0), bodyTR: new Position(35, 0),
                            legLS: new Position(5, 70), legLE: new Position(5, 90),
                            legRS: new Position(35, 70), legRE: new Position(35, 90),
                            armLS: new Position(10, 30), armLE: new Position(10, 30),
                            armRS: new Position(30, 30), armRE: new Position(30, 30),
                            eyeL: new Position(9, 11), eyeR: new Position(31, 11),
                            earLS: new Position(5, 0), earLE: new Position(5, -5),
                            earRS: new Position(35, 0), earRE: new Position(35, -5),
                            nouth: new Position(20, 20), // Not a typo, the N is intentional!
                        },
                        function(w = "full") {
                            // This should do for now
                            if(w == "full") { return new Polygon([
                                this.bodyCoords("bodyTL"),
                                this.bodyCoords("legLS"),
                                this.bodyCoords("legLE"),
                                this.bodyCoords("legRE"),
                                this.bodyCoords("legRS"),
                                this.bodyCoords("bodyTR")
                            ]); } else if(w == "top") { return new Polygon([
                                this.bodyCoords("bodyTL"),
                                this.bodyCoords("legLS"),
                                this.bodyCoords("legRS"),
                                this.bodyCoords("bodyTR")
                            ]); }
                        },
                        function() {
                            let showTail = true, showFace = true, showArms = false;
                            
                            // middle part
                            drawBody(this, ["bodyTL", "bodyTR", "legRS", "legLS"], 10);
                            line(this.bodyCoords("legLS"), this.bodyCoords("legLE"));
                            line(this.bodyCoords("legRS"), this.bodyCoords("legRE"));
                            line(this.bodyCoords("earLS"), this.bodyCoords("earLE"));
                            line(this.bodyCoords("earRS"), this.bodyCoords("earRE"));
                            
                            if(showTail) {
                                let offx = -0.2 * Math.abs(this.angle), offy = 0.17 * Math.abs(this.angle), sizeMult = 1;
                                for(let i of this.tail) {
                                    circle([i[0] + this.xpos + offx, i[1] + this.ypos + offy], sizeMult * (20 - 1 * this.tail.indexOf(i)), "white");
                                }
                            }
                            if(showFace) {
                                ctx.lineWidth = 5;
                                if(this.dead) {
                                } else if(this.stunTime) {
                                    line(this.bodyCoords("eyeL", 0.5 * this.xvel, 3), this.bodyCoords("eyeL", 0.5 * this.xvel, -3), "black");
                                    line(this.bodyCoords("eyeR", 0.5 * this.xvel, 3), this.bodyCoords("eyeR", 0.5 * this.xvel, -3), "black");
                                } else {
                                    circle(this.bodyCoords("eyeL", 0.5 * this.xvel), 5);
                                    circle(this.bodyCoords("eyeR", 0.5 * this.xvel), 5);
                                }
                                circle(this.bodyCoords("nouth", 0.5 * this.xvel), 3);
                            }
                            if(showArms) {
                                line(this.bodyCoords("armLS"), this.bodyCoords("armLE"));
                                line(this.bodyCoords("armRS"), this.bodyCoords("armRE"));
                            }
                        },
                        function() {
                            // Tick func
                            if(this.in("stand")) {
                                if(pressedKeys["39"] && !pressedKeys["37"]) {
                                    if((this.facing == 1 && this.state == "stand.walk") || this.state == "stand.idle") {
                                        this.builtSpeed++;
                                        this.xvel += 0.2;
                                        this.state = "stand.walk";
                                    } else {
                                        if(this.builtSpeed >= 60 || (this.xvel < 1 && this.state == "stand.turn" && this.facing == 1)) {
                                            // LATER! Particles
                                            this.state = "stand.turn";
                                            this.xvel += 0.2;
                                            if(this.xvel >= 1) this.state == "stand.walk"; // LATER! boost velocity
                                        } else {
                                            // Just turn around normally
                                            this.xvel += 0.5;
                                            this.lgp = [5, 35];
                                            this.state = "stand.walk";
                                        }
                                        this.builtSpeed = 0;
                                    }
                                    this.facing = 1;
                                } else if(pressedKeys["37"]) {
                                    if((this.facing == -1 && this.state == "stand.walk") || this.state == "stand.idle") {
                                        this.builtSpeed++;
                                        this.xvel -= 0.2;
                                        this.state = "stand.walk";
                                    } else {
                                        if(this.builtSpeed >= 60 || (this.xvel > -1 && this.state == "stand.turn" && this.facing == -1)) {
                                            // LATER! Particles
                                            this.state = "stand.turn";
                                            this.xvel -= 0.2;
                                            if(this.xvel <= -1) this.state == "stand.walk"; // LATER! boost velocity
                                        } else {
                                            // Just turn around normally
                                            this.xvel -= 0.5;
                                            this.lgp = [5, 35];
                                            this.state = "stand.walk";
                                        }
                                        this.builtSpeed = 0;
                                    }
                                    this.facing = -1;
                                } else {
                                    // Not moving either right or left
                                    this.state = "stand.idle";
                                    this.xvel *= 0.8;
                                    this.builtSpeed *= 0.9;
                                    // Stop walking
                                    this.lgp = [5, 35];
                                }
                                if(pressedKeys["90"]) {
                                    // Jump
                                    this.yvel = -6;
                                    this.state = "fall.idle";
                                }
                                if(pressedKeys["40"]) {
                                    // Crouch
                                    // THINK! Do I need to add more? Yes, I think so.
                                    this.state = "crouch.idle";
                                }
                                
                                // Angling
                                this.goalAngle = 0;
                            } else if(this.in("fall")) {
                                if(pressedKeys["90"] && this.state == "fall.slide") {
                                    // Wall jump
                                    this.yvel = -4;
                                    this.xvel = this.facing * -4;
                                }
                                if(pressedKeys["39"] && !pressedKeys["37"]) {
                                    this.facing = 1;
                                    this.xvel += 0.05;
                                    this.state = "fall.drift";
                                } else if(pressedKeys["37"]) {
                                    this.facing = -1;
                                    this.xvel -= 0.05;
                                    this.state = "fall.drift";
                                } else if(!this.contact()) {
                                    this.state = "fall.idle";
                                }
                                
                                this.lgp = ((pressedKeys["39"] || pressedKeys["37"]) ? [5 - this.facing * 10, 30 - this.facing * 10] : [5, 35]);
                            } else if(this.in("crouch")) {
                                // Crawling
                                // FIRST! Fix standing up when you turn
                                if(pressedKeys["39"] && !pressedKeys["37"]) {
                                    if((this.state == "crouch.idle" || this.state == "crouch.crawl") && this.facing == -1) {
                                        this.state = "crouch.turn";
                                    } else if(this.state == "crouch.idle" || (this.facing == 1 && this.state == "crouch.crawl")) {
                                        // Move forward
                                        this.state = "crouch.crawl";
                                        this.builtSpeed++;
                                        if(pressedKeys["40"]) { this.xvel += 0.05; } else { this.xvel += 0.1; }
                                    }
                                    this.facing = 1;
                                } else if(pressedKeys["37"]) {
                                    if((this.state == "crouch.idle" || this.state == "crouch.crawl") && this.facing == 1) {
                                        this.state = "crouch.turn";
                                    } else if(this.state == "crouch.idle" || this.state == "crouch.crawl") {
                                        // Move forward
                                        this.state = "crouch.crawl";
                                        this.builtSpeed++;
                                        if(pressedKeys["40"]) { this.xvel -= 0.05; } else { this.xvel -= 0.1; }
                                    }
                                    this.facing = -1;
                                } else {
                                    // Slow down
                                    this.xvel *= 0.8;
                                }
                                if(pressedKeys["38"]) {
                                    // Get up
                                    this.state = "stand.idle";
                                }
                                
                                // Angling
                                this.goalAngle = this.facing * 90;
                                if(this.state == "crouch.turn" && this.facing * 90 == this.angle) this.state = "crouch.idle";
                            }
                            
                            // Stun timer
                            if(this.stunTime) {
                                this.goalAngle = this.facing * 90;
                                this.stunTime = Math.max(0, this.stunTime - 1);
                                if(!this.stunTime) this.state = "stun.recover";
                            } else if(this.state == "stun.recover") {
                                this.goalAngle = 0;
                                if(!this.angle) this.state = "stand.idle";
                            }
                            
                            // Tilt
                            if((this.in("stand") || (this.in("fall") && this.state != "fall.slide")) && !this.colliding) {
                                this.btgp = 2 * this.xvel;
                            }
                            
                            // Horizontal movement
                            this.xpos += this.xvel;
                            if(this.contact()) {
                                //alert("Xvel contact.");
                                // Try to just walk upwards
                                let checks = 0;
                                while(checks < 10 && this.contact() && !this.in("fall")) { // No, you can't WALK up while FALLING
                                    this.xpos -= 0.1 * this.xvel;
                                    this.ypos -= 0.2 * this.xvel;
                                    checks++;
                                }
                                if(checks == 10 || this.in("fall")) {
                                    // Aww... Undo that
                                    //this.xpos -= this.xvel;
                                    this.xpos -= 0.1 * (10 - checks) * this.xvel;
                                    this.ypos += 0.2 * checks * this.xvel;
                                    if(this.in("stand")) {
                                        if(this.xvel > 0) {
                                            this.lgp = [30, 35];
                                        } else {
                                            this.lgp = [5, 10];
                                        }
                                    }
                                    // Wall sliding - reduce yvel & put into WS state
                                    if(this.in("fall") && ((pressedKeys["39"] && this.xvel > 0) || (pressedKeys["37"] && this.xvel < 0))) {
                                        this.state = "fall.slide";
                                        this.yvel *= 0.8;
                                        this.colliding = 5; // Stop BTGP for a few frames
                                        let b = this.btgp;
                                        this.btgp = 0;
                                        if(this.contact()) {
                                            this.xpos -= b;
                                        }
                                        
                                    }
                                    this.xvel *= 0.8;
                                }
                            } else { this.colliding = Math.max(0, this.colliding - 1); }
                            // Horizontal friction
                            if(this.in("fall")) this.xvel *= 0.98;
                            else this.xvel *= 0.95;
                            
                            // Vertical movement
                            this.ypos += this.yvel + 3;
                            if(this.contact() && this.in("fall")) {
                                let obj = this.contact();
                                let top = (obj instanceof Rectangle ? obj.ypos : null);
                                // I'm willing to use this approximation (the global bottom of the polygon rather than the local one)
                                let bottom = (this.getHitbox() instanceof Rectangle ? (this.getHitbox().ypos + this.getHitbox().height) : this.getHitbox() instanceof Polygon ? this.getHitbox().dims().bottom : null);
                                // Make sure the distance is reasonable -- no large teleports upward
                                if(top && bottom) {
                                    if(bottom - top < 30) {
                                        this.ypos -= (bottom - top);
                                    } else {
                                        this.ypos -= this.yvel;
                                    }
                                } else {
                                    this.ypos -= this.yvel;
                                }
                                if(this.yvel > 20) { // THINK! Figure out the right fall stun threshold
                                    this.stun(5 * (this.yvel - 15));
                                } else if(this.state != "fall.slide" && !this.in("crouch")) {
                                    // Just move around a little to make sure nothing weird is happening
                                    let c1 = this.contact();
                                    this.xvel += this.facing * 3;
                                    let c = this.contact();
                                    this.xvel -= this.facing * 3;
                                    //alert("Ouch! c1="+c1+" c="+c);
                                    if(!c1 && !c) this.state = "stand.idle";
                                } else if(this.state == "fall.slide") {
                                    // You probably just slid down to the ground
                                    //alert("Slidedown");
                                    this.state = "stand.idle";
                                }
                                this.yvel = 0;
                            } else if(this.in("fall")) {
                                this.yvel += 0.2; // Gravity
                            } else if(this.contact() && this.yvel >= 0 && this.state != "stand.walk" && !this.in("crouch")) {
                                // Climbing up
                                this.ypos -= 5;
                                // Put in crouch-state after climbing up
                                this.state = "crouch.idle";
                            }
                            // Did you just walk off the edge
                            this.ypos += 3;
                            if(!this.contact() && !this.in("fall")) {
                                this.state = "fall.idle";
                            }
                            this.ypos -= 6;
                            
                            // Changing angle
                            let speed = (this.in("stun") ? 10 : 5);
                            let oa = this.angle;
                            if(this.angle < this.goalAngle) {
                                this.angle = Math.min(this.goalAngle, this.angle + speed);
                            } else {
                                this.angle = Math.max(this.goalAngle, this.angle - speed);
                            }
                            if(this.contact()) {
                                this.angle = oa + (oa > 0 ? -1 : 1);
                                this.goalAngle = 0;
                                //alert(this.state+" « before »");
                                if(this.state == "crouch.idle") {this.state = "stand.idle";}
                                //alert(this.state+" « after »");
                            }
                            let cx = 5, cy = (this.facing == 1 ? 60 : 90);
                            for(let i of Object.values(this.body)) {
                                i.cx = cx; i.cy = cy;
                            }
                            
                            // Moving forward - make the legs move back, then check if they need to be moved forward
                            if(this.state == "stand.walk") {
                                if(this.facing == 1) {
                                    this.lgp[0] -= this.xvel;
                                    this.lgp[1] -= this.xvel;
                                    if(this.lgp[0] <= -20) this.lgp[0] = 60;
                                    if(this.lgp[1] <= -20) this.lgp[1] = 60;
                                } else {
                                    this.lgp[0] -= this.xvel;
                                    this.lgp[1] -= this.xvel;
                                    if(this.lgp[0] >= 60) this.lgp[0] = -20;
                                    if(this.lgp[1] >= 60) this.lgp[1] = -20;
                                }
                            } else if(this.state == "stand.turn") {
                                if(this.facing == 1) {
                                    this.lgp[0] = -20;
                                    this.lgp[1] = 10;
                                } else {
                                    this.lgp[0] = 30;
                                    this.lgp[1] = 60;
                                }
                            }
                            
                            // Right now, I don't need to use `this.agp`, but it'll be relevant later
                            
                            // Now use `this.lgp`, `this.agp`, and `this.btgp` to move the actual stuff
                            for(let i of [["legLE", this.lgp[0]], ["legRE", this.lgp[1]], ["armLE", this.agp[0]], ["armRE", this.agp[1]]]) {
                                if(this.contact()) continue;
                                this.body[i[0]].xpos += 0.1 * (i[1] - this.body[i[0]].xpos);
                                if(this.contact()) {
                                    this.body[i[0]].xpos -= 0.1 * (i[1] - this.body[i[0]].xpos);
                                }
                            }
                            
                            if((this.in("stand") || this.in("fall")) && Math.abs(this.angle) < 1) {
                                this.body.bodyTL.xpos += 0.1 * (this.btgp + 5 - this.body.bodyTL.xpos);
                                this.body.bodyTR.xpos += 0.1 * (this.btgp + 35 - this.body.bodyTR.xpos);
                                this.body.earLS.xpos += 0.1 * (this.btgp + 5 - this.body.earLS.xpos);
                                this.body.earLE.xpos += 0.1 * (this.btgp + 5 - this.body.earLE.xpos);
                                this.body.earRS.xpos += 0.1 * (this.btgp + 35 - this.body.earRS.xpos);
                                this.body.earRE.xpos += 0.1 * (this.btgp + 35 - this.body.earRE.xpos);
                                this.body.eyeL.xpos += 0.1 * (this.btgp + 9 - this.body.eyeL.xpos);
                                this.body.eyeR.xpos += 0.1 * (this.btgp + 31 - this.body.eyeR.xpos);
                                this.body.nouth.xpos += 0.1 * (this.btgp + 20 - this.body.nouth.xpos);
                            } else {
                                // Clear out BTGP
                                this.body.bodyTL.xpos += this.btgp + 5 - this.body.bodyTL.xpos;
                                this.body.bodyTR.xpos += this.btgp + 35 - this.body.bodyTR.xpos;
                                this.body.earLS.xpos += this.btgp + 5 - this.body.earLS.xpos;
                                this.body.earLE.xpos += this.btgp + 5 - this.body.earLE.xpos;
                                this.body.earRS.xpos += this.btgp + 35 - this.body.earRS.xpos;
                                this.body.earRE.xpos += this.btgp + 35 - this.body.earRE.xpos;
                                this.body.eyeL.xpos += this.btgp + 9 - this.body.eyeL.xpos;
                                this.body.eyeR.xpos += this.btgp + 31 - this.body.eyeR.xpos;
                                this.body.nouth.xpos += this.btgp + 20 - this.body.nouth.xpos;
                                this.btgp = 0;
                            }
                            
                            // Angle stuff
                            // Rotate most things about SC's center (20, 35)
                            for(let i of ["bodyTL", "bodyTR", "earLS", "earLE", "armLS", "armRS", "earRS", "earRE", "eyeL", "eyeR", "nouth", "legLS", "legRS"]) {
                                this.body[i].angle = this.angle;
                            }

                            // Tail
                            if(!this.tail.length) this.tail = [[20, 60]];
                            for(let i=1; i<15; i++) {
                                if(this.tail.length <= i) this.tail.push(this.tail[i - 1]);
                                let otx = this.tail[i-1][0], oty = this.tail[i-1][1], tx = this.tail[i][0] - otx, ty = this.tail[i][1] - oty;
                                tx += (this.facing == 1 ? -7 : 7);
                                ty += 4;
                                
                                let dx = otx + tx + this.xpos, dy = oty + ty + this.ypos, MAXDIST = 10 - 0.5 * i;
                                while(new Rectangle(dx - MAXDIST, dy - MAXDIST, MAXDIST * 2, MAXDIST * 2).touches(this.room.hitbox)) {
                                    ty -= 1;
                                    tx -= -1 * this.facing;
                                    // Recalc!
                                    dx = otx + tx + this.xpos; dy = oty + ty + this.ypos;
                                }
                                
                                let dist = Math.sqrt(tx*tx + ty*ty);
                                if(dist > MAXDIST) {
                                    //alert(dist + " >> " + MAXDIST);
                                    tx /= (dist / MAXDIST);
                                    ty /= (dist / MAXDIST);
                                }
                                this.tail[i] = [otx + tx, oty + ty];
                            }
                        }
                    );
                    
                    this.lgp = [5, 35]; // Leg Goal Pos - where I want to put the legs
                    this.agp = [10, 30]; // Arm Goal Pos - where I want to put the arms
                    this.btgp = 0; // Body Top Goal Pos
                    this.facing = 1; // 1 or -1
                    this.xvel = 0;
                    this.yvel = 0;
                    this.builtSpeed = 0; // How long you've been going in the current direction
                    this.tail = [];
                    this.angle = 0, this.goalAngle = 0; // Where you want to turn
                    this.stunTime = 0;
                    this.colliding = 0; // Whether to stop BTGP due to a collision
                }
                stun(time) {
                    // Set state & timer
                    this.state = "stun.idle";
                    this.stunTime = time;
                    // LATER! Drop what you're holding
                }
            }
            
            let SC, rooms = [];
            
            try {
                let startRoom = new Room(
                    // FG MG BG
                    [new Rectangle(300, 50, 100, 250, "#633")],
                    [
                        new Rectangle(10, 50, 80, 350, "#363"),
                        new Rectangle(900, 50, 80, 350, "#363"),
                        new Rectangle(110, 320, 700, 80, "#363"),
                        new Polygon([[250, 320], [280, 250], [330, 320]], "#363"), // Wtf is this
                    ],
                    [new Rectangle(500, 50, 100, 250, "#336")]
                );
                rooms.push(startRoom);
                SC = new Player(startRoom);
            } catch(e) { alert("Error in init: " + e); }
            
            function frame(globalTimer) { try {
                ctx.clearRect(0, 0, 1350, 630);
                SC.room.render();
                for(let i of rooms) {
                    for(let j of i.entities) { j.tick(); }
                }
                newKeys = [];
                
                document.getElementById("sayer").innerHTML = `state=${SC.state} facing=${SC.facing} vel=(${SC.xvel.toFixed(1)},${SC.yvel.toFixed(1)}) pos=(${SC.xpos.toFixed(1)},${SC.ypos.toFixed(1)}) angle=${SC.angle} (${SC.goalAngle}) hb=${SC.getHitbox().touches(SC.room.hitbox)} bspeed=${SC.builtSpeed.toFixed(0)}`;
                
                window.requestAnimationFrame(frame);
            } catch(e) { alert("Error in frame(): " + e); } }

            document.addEventListener("keydown", function(e) {
                let k = e.keyCode;
                //alert("Key pressed: " + k);
            });
            function loaded() {
                ctx = document.getElementById("canv").getContext("2d");
                window.requestAnimationFrame(frame);
            }
        </script>
    </head>
    <body onload="loaded()">
        <div id="sayer">an experiment in animation</div>
        <canvas id="canv" width="1350" height="630"></canvas>
    </body>
</html>
